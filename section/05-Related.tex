
\label{s:Related}
\section{Related Work}

% ---------------------------------------------------------
\subsection{Linda-style Tuple Spaces}
Linda~\cite{Gelernter1985:Linda} is a coordination model where processes communicate by adding, removing and non-destructively reading tuples from a globally shared tuple space. The basic Linda model is open, meaning that any party using it is free to add and remove tuples at will. This lack of access control or provenance information makes it unusable for as a communication medium for mutually distrusting parties.

Several extensions to the basic Linda model add metadata to the tuples that are similar to the `by' and `obs' authority sets of our own Rainfall model. SecSpaces~\cite{Busi2003:SecSpaces} signs tuples with the private keys of parties that create them, and adds metadata that specifies the identities of those that can see and consume them. Merrick~\cite{Merrick2000:Scopes} describes a scoping/visibility system for tuple spaces where new scopes can be created at will and combined using a set of scope combinators. Oriol~\cite{Oriol2005:TaggedSets} describes a model of tagged sets where the tuples are identified by a formula in propositional logic that allows authority and visibility information to be encoded uniformly. Udzir~\cite{Udzir2007:MultiCapabilities}~describes a model where collections of tuples have unique identifiers, and the client program must provide a matching runtime capability when accessing them. These systems refine the Linda data model, but do not provide a mechanism to allow parties using the system to combine authorized tuples to produce new ones that are authorized by any other party except themselves. The ability to do this is the main contribution of our own system.


% ---------------------------------------------------------
\subsection{Law Governed Linda}
Law Governed Linda~(LGL)~\cite{Minsky1994:LawGovernedLinda, Minsky2001:SafeTupleSpace} takes the basic Linda data model and inserts a \emph{controller} between the tuple space and each communicating process. Each controller has a copy of a communication law, written in a fragment of Prolog, that specifies the allowable interactions with the tuple space. For example, the law could  state that a process may only create a tuple that includes a @from@ field, when the value in that field is its own process identifier.

The codified law specifies the allowable \emph{interaction} a process may have with the communication medium. The controllers are assumed to run on a trusted computing base, either as part of the physical server that provides the tuple space, or on a secure co-processor~\cite{Minsky2001:SafeTupleSpace}. In contrast, the production rules in our Rainfall model do not limit the form of data added to the system. Instead, they specify how authorized facts that are already in the store may be combined to produce new authorized facts. The Authority Flow theorem of \S\ref{s:PropertiesOfSemantics} ensures that we do not need to rely on a trusted computing base to enforce the rules of the system.


% ---------------------------------------------------------
\subsection{Extended Shared Prolog}
\label{s:RelatedESP}
Like LGL, Extended Shared Prolog (ESP)~\cite{Ciancarini1993:Coordinating, Ciancarini1994:LogicTupleSpaces} combines the Linda coordination model with rules written in a restricted subset of Prolog. In this case the rules are stored as special \emph{program tuples} in the main tuple space, and the rules describe how existing tuples can be combined, rather than controlling the interaction between the tuple space and its clients. The format of each rule is similar to a Rainfall production rule, including a section to gather matching tuples, a section to decide which should be consumed, and a section to compute new tuples. Program tuples behave like triggers in an active database~\cite{Paton1999:Active}, where a rule is activated when all tuples it was waiting for become available. However, as with the basic Linda coordination model, there is no mechanism to enforce transitive authority, or track the provenance of created tuples.


% ---------------------------------------------------------
\subsection{Permissioned Distributed Ledgers}
\label{s:RelatedPermissioned}
As mentioned in \S\ref{s:NestedTransactions}, DAML combines facts and rules into a \emph{contract instance}, which is similar to an object in an Object-Oriented (OO) model. Objects are referred to by \emph{contract identifiers}, which are equivalent to typed references in the OO model. The DAML coordination model is based on UTxO~\cite{Zahnentferner2018:UTxO}, so invoking a method on an object typically causes it to create some new objects, then consume/delete that object. Deleting an object causes any existing references to it to become dangling, and following a dangling reference at runtime causes an exception. In contrast, our Rainfall model identifies facts by their content, rather than using a physical reference or pointer value. If a particular fact is not available with sufficient weight then this inhibits rule firing, rather than being treated as an execution failure.

A DAML method can invoke methods on other objects that it already has a reference to, but cannot query the ledger state directly. This restriction is standard in the OO coordination model, where method code cannot directly query the runtime heap to discover other objects based on their field data. Instead, objects typically communicate using shared references to mutable data. However, as the DAML programming model purposefully does not include shared mutable data, the usual OO programming patterns are unavailable. In practice, ledger actions are coordinated by ``nanobots'', which are driver routines written in an external language. The query performed by a nanobot yields a set of contract identifiers, which are then passed to DAML code as arguments to method invocations. The Rainfall model was specifically developed to avoid the need for nanobots, while providing an authority system similar the one available in DAML.

Corda~\cite{Hearn2016:Corda}, and Hyperledger Fabric~\cite{Androulaki2018:Fabric} are related permissioned distributed ledgers. Instead of defining a specific contract language, both systems allow custom procedures to be installed that accept transactions directly and report whether they are valid. In Corda the validation procedures are expressed in a version of JVM bytecode that has been modified to ensure execution is deterministic. In Hyperledger Fabric the validation procedures can be arbitrary native code encapsulated in a Docker~\cite{Docker2019} container. These systems both provide the networking layer for a distributed ledger system, but purposefully do not specify a programming model in sufficient detail to prove safety properties such as those in \S\ref{s:Properties}, leaving this as a separate implementation choice.


% ---------------------------------------------------------
\subsection{Actors, Process Algebras, and Constraints}
Production rule systems like Rainfall have a passing similarity to the Actor~\cite{Agha92:ActorTheory} model, but the computation framework is quite different. Production rules do not maintain their own private state, or have instance identity in the sense that they are addressable by mailbox or channel names. However, one could compile an actor program \emph{into} Rainfall, by building facts that represent the local state of each actor, and defining production rules to handle the messages. A proposed extension to Erlang provides the multi-headed pattern matching needed by production rules~\cite{Sulzmann2008:MultiHeaded}, though matching is performed on ordered streams of incoming messages, rather selecting from an unordered soup of tuples. ActorSpaces~\cite{Agha1993:ActorSpace} is a related model that uses message passing for communication while also allowing messages to be broadcast to all actors in a group.

Existing process languages such as the Join Calculus~\cite{Cedric1996:Reflexive} and the Chemical Abstract Machine~(CHAM)~\cite{Berry1992:Chemical} allow processes to wait for multiple related facts (messages) to become available before activating. Similar functionality is available in systems of Constraint Handling Rules (CHR)~\cite{Fruthwirth1998:CHRs}. However, as with Extended Shared Prolog~(\S\ref{s:RelatedESP}) these systems do not have a built in authority or provenance mechanism that could be used to guide data privacy as described in \S\ref{s:Privacy}.


% ---------------------------------------------------------
\subsection{Authorization Logics}
The Dependency Core Calculus (DCC)~\cite{Abadi1999:DCC} extends Moggi's computational lambda calculus with an extra judgment form that indicates the value produced by a computation is protected at a given security level. Abadi~\cite{Abadi2007:AccessControl} studies DCC applied to access control and tracking in a distributed system. This work uses a proposition $(P~\trm{says}~A)$, where $P$ is some principle/party that affirms statement $A$. The `says' former abstracts away from the details of what exactly is being authenticated or authorized. The statement $(P~\trm{says}~A)$ can variously be interpreted as ``$P$ has caused $A$ to be said'', ``$A$ has been said on $P$'s behalf'' or ``$P$ supports $A$''. Garg~\cite{Garg2006:Constructive} gives a sequent style presentation with two judgement forms $(A~\trm{true})$ and $(P~\trm{affirms}~A)$. The `affirms' form is internalized as a proposition $(P~\trm{says}~A)$. Garg's system comes with meta theory of Affirmation Flow, meaning that unless a principle P affirms a particular statement, no affirmations of the form $(P~\trm{affirms}~A)$ can be derived from it. Bowers~\cite{Bowers2007:Consumable} gives a natural deduction style presentation that also has a $(P~\trm{signed}~A)$ form to model a message being cryptograpically signed.

DCC and related systems are logics rather than programming languages that have a direct operational interpretation. The Aura language~\cite{Jia2008:Aura} then specifies a functional operational semantics, as well as a proof term assignment for a version of DCC. Proofs of authority can be passed to functions as pure proof terms. Rainfall is directly inspired by the DCC family of logics and languages. Instead of building functional proof terms to demonstrate authority, we gather it in stages, incrementally writing authorized facts back to the ledger. Our ledger then can be viewed as a distributed proof of authority, where versions of DCC style logical properties still apply. For example, our Authority Flow theorem (\S\ref{s:Properties}) is the operational version of Garg's~\cite{Garg2006:Constructive} Affirmation Flow.
