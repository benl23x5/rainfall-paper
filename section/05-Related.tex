

\label{s:Related}
\section{Related Work}

% TODO: Distinguish between authorized fact production and contract pricing systems. Rainfall isn't about pricing

% TODO: Describe how Rainfall rules have no breach state. Does not fit well into framework of Deontic or Defeasible logic, even though these are commonly used to describe contracts.

% ---------------------------------------------------------
\subsection{Linda-style Tuple Spaces}
Linda~\cite{Gelernter1985:Linda} is a coordination model where processes communicate by adding, removing and non-destructively reading tuples from a globally shared tuple space. The basic Linda model is open, meaning that any party using it is free to add and remove tuples at will. This lack of access control or provenance information makes it unusable for as a communication medium for mutually distrusting parties.

Several extensions to the basic Linda model add metadata to the tuples that are similar to the `by' and `obs' authority sets of our own Rainfall model. SecSpaces~\cite{Busi2003:SecSpaces} signs tuples with the private keys of parties that create them, and adds metadata that specifies the identities of those that can see and consume them. Merrick~\cite{Merrick2000:Scopes} describes a scoping/visibility system for tuple spaces where new scopes can be created at will and combined using a set of scope combinators. Oriol~\cite{Oriol2005:TaggedSets} describes a model of tagged sets where the tuples are identified by a formula in propositional logic that allows authority and visibility information to be encoded uniformly. Udzir~\cite{Udzir2007:MultiCapabilities}~describes a model where collections of tuples have unique identifiers, and the client program must provide a matching runtime capability when accessing them. These systems refine the Linda data model, but do not provide a mechanism to allow parties using the system to combine authorized tuples to produce new ones that are authorized by any other party except themselves. The ability to do this is the main contribution of our own system.


% ---------------------------------------------------------
\subsection{Law Governed Linda}
Law Governed Linda~(LGL)~\cite{Minsky1994:LawGovernedLinda, Minsky2001:SafeTupleSpace} takes the basic Linda data model and inserts a \emph{controller} between the tuple space and each communicating process. Each controller has a copy of a communication law, written in a fragment of Prolog, that specifies the allowable interactions with the tuple space. For example, the law could  state that a process may only create a tuple that includes a @from@ field, when the value in that field is its own process identifier.

The codified law specifies the allowable \emph{interaction} a process may have with the communication medium. The controllers are assumed to run on a trusted computing base, either as part of the physical server that provides the tuple space, or on a secure co-processor~\cite{Minsky2001:SafeTupleSpace}. In contrast, the production rules in our Rainfall model do not limit the form of data added to the system. Instead, they specify how authorized facts that are already in the store may be combined to produce new authorized facts. The Authority Flow theorem of \S\ref{s:PropertiesOfSemantics} also ensures we do not need to rely on a trusted computing base to enforce the rules of the system.


% ---------------------------------------------------------
\subsection{Extended Shared Prolog}
\label{s:RelatedESP}
Like LGL, Extended Shared Prolog (ESP)~\cite{Ciancarini1993:Coordinating, Ciancarini1994:LogicTupleSpaces} combines the Linda coordination model with rules written in a restricted subset of Prolog. In this case the rules are stored as special \emph{program tuples} in the main tuple space, and the rules describe how existing tuples can be combined, rather than controlling the interaction between the tuple space and its clients. The format of each rule is similar to a Rainfall production rule, including a section to gather matching tuples, a section to decide which should be consumed, and a section to compute new tuples. Program tuples behave like triggers in an active database~\cite{Paton1999:Active}, where a rule is activated when all tuples it was waiting for become available. However, as with the basic Linda coordination model, there is no mechanism to enforce transitive authority, or track the provenance of created tuples.

% Rainfall takes extends the basic ESP model with an authority mechanism to track which parties authorize the production of which facts, which allows the safe execution of multiparty contracts. ESP program rules are also anonymous, where the Rainfall system relies on them having names so that these names can be mentioned in the facts.

% Another minor difference is that the ESP fact matching system does not have direct support for aggregation operators as used in \REF. Aggregation is a key operation in regular database query languages, though usually not a primitive operation in Prolog style systems based around matching of Horn clauses. However, one can imagine support for aggregations being added via \emph{view tuples}, where the act of matching invokes an aggregation operation across some larger subset of the tuple space, as per LighTS~\cite{Balzarotti2007:LighTS}.


% ---------------------------------------------------------
\subsection{Permissioned Distributed Ledgers}
\label{s:RelatedPermissioned}
As mentioned in \S\ref{s:NestedTransactions}, DAML combines facts and rules into a \emph{contract instance}, which is similar to an object in an Object-Oriented (OO) model. Objects are referred to by \emph{contract identifiers}, which are equivalent to typed references in the OO model. The DAML coordination model is based on UTxO~\cite{Zahnentferner2018:UTxO}, so invoking a method on an object typically causes it to create some new objects, then consume/delete that object. Deleting an object causes any existing references to it to become dangling, and following a dangling reference at runtime causes an exception. In contrast, our Rainfall model identifies facts by their content, rather than using a physical reference or pointer value. If a particular fact is not available with sufficient weight then this inhibits rule firing, rather than being treated as an execution failure.

A DAML method can invoke methods on other objects that it already has a reference to, but cannot query the ledger state directly. This is restriction is standard in OO coordination models, where method code cannot directly query the runtime heap to discover other objects based on their field data. Objects typically communicate using shared references to mutable data. However, as the DAML programming model purposefully does not include shared mutable data, the usual OO programming patterns are unavailable. In practice, ledger queries are performed by ``nanobots'', which are driver routines written in an external language. The query performed by a nanobot yields a set of references to active DAML contract instances (objects), which are then passed back to the DAML code as arguments on method invocations. The Rainfall model was specifically developed to avoid the need for nanobots, while providing an authority system similar the one in DAML.

% Source level DAML programs could be converted to the Rainfall model by representing active DAML contract instances as facts listing their fields, and splitting each method into a separate rule. A party wishing to invoke a method would add a fact listing the arguments to that method, and the associated rule would consume both facts.

Corda~\cite{Hearn2016:Corda}, and Hyperledger Fabric~\cite{Androulaki2018:Fabric} are related permissioned distributed ledgers. Instead of defining a specific contract language, both systems allow custom procedures to be installed that accept transactions directly and report whether they are valid. In Corda the validation procedures are expressed in a version of JVM bytecode that has been modified to ensure execution is deterministic. In Hyperledger Fabric the validation procedures can be arbitrary native code encapsulated in a Docker~\cite{Docker2019} container. These systems both provide the networking layer for a distributed ledger system, but purposefully do not specify a programming model in sufficient detail to prove safety properties such as those in \S\ref{s:Properties}. Leaving this as a separate implementation design choice.



% ---------------------------------------------------------
\subsection{Actors, Process Algebras, and Constraints}
Production rule systems like Rainfall have a passing similarity to the Actor~\cite{Agha92:ActorTheory} model, but the computation framework is quite different. Production rules do not maintain their own private state, or have instance identity in the sense that they are addressable by mailbox or channel names. However, one could compile an actor program \emph{into} Rainfall, by building facts that represent the local state of each actor, and defining production rules to handle the messages. A proposed extension to Erlang provides the multi-headed pattern matching needed by production rules~\cite{Sulzmann2008:MultiHeaded}, though matching is performed on ordered streams of incoming messages, rather selecting from an unordered soup of tuples. ActorSpaces~\cite{Agha1993:ActorSpace} is a related model that uses message passing communication while also allowing messages to be broadcast to all actors in a group.

Existing process languages such as the Join Calculus~\cite{Cedric1996:Reflexive} and the Chemical Abstract Machine~(CHAM)~\cite{Berry1992:Chemical} allow processes to wait for multiple related facts (messages) to become available before activating. Similar functionality is available from of Constraint Handling Rules (CHR)~\cite{Fruthwirth1998:CHRs}. However, as with Extended Shared Prolog~(\S\ref{s:RelatedESP}) these systems do not have a builtin authority or provenance mechanism that could be used to guide data privacy as described in \S\ref{s:Privacy}.


% ---------------------------------------------------------
\subsection{Authorization Logics}
The Dependency Core Calculus (DCC)~\cite{Abadi1999:DCC} extends Moggi's computational lambda calculus with an extra judgment form that indicates the value produced by a computation is protected at a given security level. Abadi~\cite{Abadi2007:AccessControl} studies DCC applied to access control and tracking in a distributed system. This work uses a proposition $(P~\trm{says}~A)$, where $P$ is some principle/party that affirms statement $A$. The 'says' former abstracts away from the details of what exactly is being authenticated or authorized. The statement $(P~\trm{says}~A)$ can variously be interpreted as ``$P$ has caused $A$ to be said'', ``$A$ has been said on $P$'s behalf'' or ``$P$ supports $A$''. Garg~\cite{Garg2006:Constructive} gives a sequent style presentation with two judgement forms $(A~\trm{true})$ and $(P~\trm{affirms}~A)$. The `affirms' form is internalized as a proposition $(P~\trm{says}~A)$. Garg's system comes with meta theory of Affirmation Flow, meaning that unless a principle P affirms a particular statement, no affirmations of the form $(P~\trm{affirms}~A)$ can be derived from it. Bowers~\cite{Bowers2007:Consumable} gives a Gentzen style presentation that also has a $(P~\trm{signed}~A)$ form to model a message being cryptograpically signed.

DCC and related systems are logics rather than programming languages that have a direct operational interpretation. The Aura language~\cite{Jia2008:Aura} then specifies a functional operational semantics, as well as a proof term assignment for a version of DCC. Proofs of authority can be passed to functions as pure proof terms. Rainfall is directly inspired by the DCC family of logics and languages. Instead of building functional proof terms to demonstrate authority, we gather it in stages, incrementally writing authorized facts back to the ledger. Our ledger then can be viewed as a distributed proof of authority, where versions of DCC style logical properties still apply. For example, our Authority Flow theorem (\S\ref{s:Properties}) is the operational version of Garg's~\cite{Garg2006:Constructive} Affirmation Flow.


% TODO: describe Deon Digital DSL and "Compositional Specification of Commercial Contracts", Henglein.


% Garg 2006~\cite{Garg2006:Constructive} presents a system in sequent style with two judgement forms (A true) and (K affirms A), where K is a principle (party) and A is a proposition. The 'affirms' judgement is then internalised into a proposition as (K says A). The meanings of the connectives are defined by the rules that introduce and eliminate them, rather than a concrete operationa semantics. This system comes with meta theory of affirmation flow, meaning that unless a principle K affirms a statement, no affirmations of the form (K affirms A) can be derived from it.

% Bowers 2007~\cite{Bowers2007:Consumable} contains a Gentzen style presentation of Garg 2006 that adds a linear environment to enforce that particular statements (K says A) are only used once in a given authority proof. It also has a (A signed F) form to model a message being cryptograpically signed. Includes an informal discussion of how linear uses of predicates can be enforced in a distributed environment by reling on a central ratifier to check the proofs.

% Aura~\cite{Jia2008:Aura} is a dependently typed language that includes the (A says P) form of DCC~\cite{Abadi1999:DCC} and provides a proof term assignment for the earlier pure authorization logics. The proof language is restricted to only contain proofs with no redexes, which simplifies type checking and ensures proof construction code does not perform effects. Proofs of authority are passed as pure proof terms so that fact that a given function may capture authority in its closure is not visible in its type.



% Rainfall system is not directly reactive, in the sense that there are concurrent processes waiting to receive messages and provide responses. As described in \REF, in normal use a submitting party decides when to perform a transaction according to one of the rules, and is free to disambiguate any non-determinism in pattern matching as they see fit.

% \TODO{compare with constraint handling rules:likewise CHR specifies a particular matching order for constraints, (is that right?)}


% ---------------------------------------------------------
% \subsection{Production Engines}
% Our rules are closer to those used by production rule engines OPS~\cite{Forgy1981:OPS5} latter % versions CLIPS~\cite{Riley2017:CLIPS} and Drools~\cite{Proctor2008:Drools} do perform % non-deterministic matching. Implementations based on the RETE~\cite{Forgy1981:RETE} algorithm and % enhancements \cite{Doorenbos1995:ProductionMatching} of it. Our system is similar to a production % rule engine, but with the facts annotated by sets of parties and other authority metadata. In % systems like OPS the facts are part of a global set. In our system we annotate facts with sets of % parties that control visiblity.


% ---------------------------------------------------------
%\subsection{Account Based Ledgers}
% In public account ledgers like Ethereum~\cite{Wood2014:Ethereum} and EOS.IO~\cite{Lee2018:EOSIO} all data on the ledger is visible to all parties. In these systems each account is associated with a contract that has its own mutable state. The contract code can export methods which are callable by other parties in the system. Authority is managed programatically, where method code must check at runtime that the party that calls a particular method is permitted to do so. Contracts that require authority from multiple parties to perform some action can use local mutable state to build a set of parties that have provided their consent so far. In our system the authority to create and consume facts is managed at the meta level as this also affects the whether each party can see the data.

% Rules are free to perform their own ``business level'' checks, such as ensuring that only a given set of parties can activate the rule.


% ---------------------------------------------------------
% \subsection{Petri-net Systems}
% FCL~\cite{Adjoint2019:FCL} uses a petri net model with a baked in transaction system.
% Business Process Execution Language (BPEL)~\cite{Andrews2003:BPEL} itself lacks a formal semantics. Various efforts to assign semantics, eg using Petri Nets~\cite{Lohmann2009:PetriBPEL} and Abstract State Machines \cite{Fahland2005:SemanticsBPEL}. Much of the effort is in managing compensating transactions~\cite{Colombo2011:Compensating} which are a higher level language concern.
