

\label{s:Related}
\section{Related Work}

% TODO: Distinguish between authorized fact production and contract pricing systems. Rainfall isn't about pricing

% TODO: Describe how Rainfall rules have no breach state. Does not fit well into framework of Deontic or Defeasible logic, even though these are commonly used to describe contracts.

% ---------------------------------------------------------
\subsection{Linda-style Tuple Spaces}
Linda~\cite{Gelernter1985:Linda} is a coordination model where processes communicate by adding, removing and non-destructively reading tuples from a globally shared tuple space. The basic Linda model is open, meaning that any party using it is free to add and remove tuples at will. This lack of access control or provenance information makes it unusable for as a communication medium for mutually distrusting parties.

Several extensions to the basic Linda model add metadata to the tuples that are similar to the `by' and `obs' authority sets of our own Rainfall model. SecSpaces~\cite{Busi2003:SecSpaces} signs tuples with the private keys of parties that create them, and adds metadata that specifies the identities of those that can see and consume them. Merrick~\cite{Merrick2000:Scopes} describes a scoping/visibility system for tuple spaces where new scopes can be created at will and combined using a set of scope combinators. Oriol~\cite{Oriol2005:TaggedSets} describes a model of tagged sets where the tuples are identified by a formula in propositional logic that allows authority and visibility information to be encoded uniformly. Udzir~\cite{Udzir2007:MultiCapabilities}~describes a model where collections of tuples have unique identifiers, and the client program must provide a matching runtime capability when accessing them. These systems refine the Linda data model, but do not provide a mechanism to allow parties using the system to combine authorized tuples to produce new ones that are authorized by any other party except themselves. The ability to do this is the main contribution of our own system.


% ---------------------------------------------------------
\subsection{Law Governed Linda}
Law Governed Linda~(LGL)~\cite{Minsky1994:LawGovernedLinda, Minsky2001:SafeTupleSpace} takes the basic Linda data model and inserts a \emph{controller} between the tuple space and each communicating process. Each controller has a copy of a communication law, written in a fragment of Prolog, that specifies the allowable interactions with the tuple space. For example, the law could  state that a process may only create a tuple that includes a @from@ field, when the value in that field is its own process identifier.

The codified law specifies the allowable \emph{interaction} a process may have with the communication medium. The controllers are assumed to run on a trusted computing base, either as part of the physical server that provides the tuple space, or on a secure co-processor~\cite{Minsky2001:SafeTupleSpace}. In contrast, the production rules in our Rainfall model do not limit the form of data added to the system. Instead, they specify how authorized facts that are already in the store may be combined to produce new authorized facts. The Authority Flow theorem of \S\ref{s:PropertiesOfSemantics} also ensures we do not need to rely on a trusted computing base to enforce the rules of the system.


% ---------------------------------------------------------
\subsection{Extended Shared Prolog}
Like LGL, Extended Shared Prolog (ESP)~\cite{Ciancarini1993:Coordinating, Ciancarini1994:LogicTupleSpaces} also combines the Linda coordination model with rules written in a restricted subset of Prolog. In this case the rules are stored as special \emph{program tuples} in the main tuple space. The rules describe how existing tuples can be combined, rather than controlling the interaction between the tuple space and its clients. The format of each rule is similar to Rainfall production rules, including a section to gather matching tuples, a section to decide which ones should be consumed, and a section to compute new tuples. Program tuples behave like triggers in an active database~\cite{Paton1999:Active}, where the rule is activated when the tuples it was waiting for become available. However, as with the basic Linda coordination model, there is no mechanism to enforce transitive authority, or track the provenance of created tuples.

% Rainfall takes extends the basic ESP model with an authority mechanism to track which parties authorize the production of which facts, which allows the safe execution of multiparty contracts. ESP program rules are also anonymous, where the Rainfall system relies on them having names so that these names can be mentioned in the facts.

% Another minor difference is that the ESP fact matching system does not have direct support for aggregation operators as used in \REF. Aggregation is a key operation in regular database query languages, though usually not a primitive operation in Prolog style systems based around matching of Horn clauses. However, one can imagine support for aggregations being added via \emph{view tuples}, where the act of matching invokes an aggregation operation across some larger subset of the tuple space, as per LighTS~\cite{Balzarotti2007:LighTS}.


% ---------------------------------------------------------
\subsection{Permissioned Distributed Ledgers}
\label{s:RelatedPermissioned}
DAML~\cite{DA2019:DAML}, Corda~\cite{Hearn2016:Corda}, and Hyperledger Fabric~\cite{Androulaki2018:Fabric} are permissioned distributed ledgers that have some of the authorization and privacy properties of own Rainfall model.


\TODO{Cite Corda uses a determinised JVM to specify its contracts. This is like defining our rule bodies in JVM bytecode. More on DAML, talk about problems with contract ids becoming dangling~\cite{DA2019:DAML}.}




% ---------------------------------------------------------
\subsection{Actors}
Rainfall production rules have a passing similarity to Actors~\cite{Agha92:ActorTheory}, but the computation framework is quite different. Production rules do not maintain their own private state, or have instance identity in the sense that they are addressable by mailbox or channel names. However, one could embed an actor program \emph{into} Rainfall, by building facts that represent the local state of each actor, and defining production rules to handle the messages. A proposed extension to Erlang provides the multi-headed pattern supported by production rules~\cite{Sulzmann2008:MultiHeaded}, but performs matching on ordered streams of incoming messages rather selecting from an unordered soup of tuples. ActorSpaces~\cite{Agha1993:ActorSpace} is a related model where communication is still done by message passing, but messages can be broadcast to all actors in a group, rather than just a single one as in point-to-point communication.

% Rainfall system is not directly reactive, in the sense that there are concurrent processes waiting to receive messages and provide responses. As described in \REF, in normal use a submitting party decides when to perform a transaction according to one of the rules, and is free to disambiguate any non-determinism in pattern matching as they see fit.

% \TODO{compare with constraint handling rules:likewise CHR specifies a particular matching order for constraints, (is that right?)}


% ---------------------------------------------------------
% \subsection{Production Engines}
% Our rules are closer to those used by production rule engines OPS~\cite{Forgy1981:OPS5} latter % versions CLIPS~\cite{Riley2017:CLIPS} and Drools~\cite{Proctor2008:Drools} do perform % non-deterministic matching. Implementations based on the RETE~\cite{Forgy1981:RETE} algorithm and % enhancements \cite{Doorenbos1995:ProductionMatching} of it. Our system is similar to a production % rule engine, but with the facts annotated by sets of parties and other authority metadata. In % systems like OPS the facts are part of a global set. In our system we annotate facts with sets of % parties that control visiblity.


% ---------------------------------------------------------
\subsection{Account Based Ledgers}
In public account ledgers like Ethereum~\cite{Wood2014:Ethereum} and EOS.IO~\cite{Lee2018:EOSIO} all data on the ledger is visible to all parties. In these systems each account is associated with a contract that has its own mutable state. The contract code can export methods which are callable by other parties in the system. Authority is managed programatically, where method code must check at runtime that the party that calls a particular method is permitted to do so. Contracts that require authority from multiple parties to perform some action can use local mutable state to build a set of parties that have provided their consent so far. In our system the authority to create and consume facts is managed at the meta level as this also affects the whether each party can see the data.

% Rules are free to perform their own ``business level'' checks, such as ensuring that only a given set of parties can activate the rule.


% ---------------------------------------------------------
\subsection{Petri-net Systems}
FCL~\cite{Adjoint2019:FCL} uses a petri net model with a baked in transaction system.

Business Process Execution Language (BPEL)~\cite{Andrews2003:BPEL} itself lacks a formal semantics. Various efforts to assign semantics, eg using Petri Nets~\cite{Lohmann2009:PetriBPEL} and Abstract State Machines \cite{Fahland2005:SemanticsBPEL}. Much of the effort is in managing compensating transactions~\cite{Colombo2011:Compensating} which are a higher level language concern.


% ---------------------------------------------------------
\subsection{Process Algebras}
The Join Calculus~\cite{Cedric1996:Reflexive} and Chemical Abstract Machine~\cite{Berry1992:Chemical} Process algebras that model local interaction of code and data. CHAM has very explicit rules about grouping (cooling) and ungrouping (heating) facts to form compounds. For our application we want to model locality but it's sufficient to use a seggregated global ``top level'' store, rather than than explicit nesting of stores.

\TODO{describe Deon Digital DSL and "Compositional Specification of Commercial Contracts", Henglein.}

% ---------------------------------------------------------
\subsection{Authorization Logics}
\TODO{Cut back descriptions of auth logic, don't use so much space as Rainfall is more operational, and not a logic.}

The Dependency Core Calculus (DCC)~\cite{Abadi1999:DCC} extends Moggi's computational lambda calculus with an extra judgment to say that a value produced from a computation is protected at a given security level. The computation types are written (T l a) where T is the computation type former, l an element from a lattice describing authority levels, and a the return type. The calculus has rules for monadic 'lift' and 'bind' operators to ensure results computed by bind are annotated with the required authority. The terms are given a denotational semantics, but not an operational one that dynamically checks the running term has the required authority.

Abadi 2006~\cite{Abadi2007:AccessControl} studies the use of DCC for access control and tracking in a distributed system. It uses a proposition (A says s) where 'A' is some principle/party that affirms statement 's'. The 'says' former abstracts away from the precise details of what is being authenticated or authorized. The statement (A says s) can be interpreted variously as "A has caused s to be said", "s has been said on A's behalf" or "A supports s". This work uses polymorphism to introduce delegation, providn terms of type (forall X. (A says X) implies (B says X)). As per the previous work \cite{Abadi1999:DCC} the system is presented as a logic rather than a programming language with operational meaning.

% Garg 2006~\cite{Garg2006:Constructive} presents a system in sequent style with two judgement forms (A true) and (K affirms A), where K is a principle (party) and A is a proposition. The 'affirms' judgement is then internalised into a proposition as (K says A). The meanings of the connectives are defined by the rules that introduce and eliminate them, rather than a concrete operationa semantics. This system comes with meta theory of affirmation flow, meaning that unless a principle K affirms a statement, no affirmations of the form (K affirms A) can be derived from it.

% Bowers 2007~\cite{Bowers2007:Consumable} contains a Gentzen style presentation of Garg 2006 that adds a linear environment to enforce that particular statements (K says A) are only used once in a given authority proof. It also has a (A signed F) form to model a message being cryptograpically signed. Includes an informal discussion of how linear uses of predicates can be enforced in a distributed environment by reling on a central ratifier to check the proofs.

% Aura~\cite{Jia2008:Aura} is a dependently typed language that includes the (A says P) form of DCC~\cite{Abadi1999:DCC} and provides a proof term assignment for the earlier pure authorization logics. The proof language is restricted to only contain proofs with no redexes, which simplifies type checking and ensures proof construction code does not perform effects. Proofs of authority are passed as pure proof terms so that fact that a given function may capture authority in its closure is not visible in its type.
