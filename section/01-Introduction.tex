
\section{Introduction}
Distributed ledgers allow information about virtual assets to be recorded and modified by mutually distrusting parties. A prime application of distributed ledgers is to implement cryptocurrencies such as Bitcoin, Dogecoin, Ethereum and so on. In such systems, some of the rules that specify how assets assets can be transferred between parties are baked into the ledger framework, while others can be defined in a programming language whose runtime is part of the ledger system. Early systems such as Bitcoin used a sequence of simple, non-looping bytecodes to specify the requirements for coin transfer~\cite{Atzei2017:BitcoinTransactions}. Latter systems such as the Ethereum Virtual Machine (EVM)~\cite{Wood2014:Ethereum}, EOS~\cite{Grigg2017:EosIntroduction}, Scilla~\cite{Sergey2018:Scilla}, Pact~\cite{Popejpy2016:Pact}, FCL~\cite{Adjoint2019:FCL}, Plutus~\cite{IOHK2018:Plutus} and DAML~\cite{DA2019:DAML}, are more general purpose languages that can include looping, structured data and polymorphism. We refer to these as \emph{smart contract} languages, as the intended application is to express rules and workflows for managing financial assets~\cite{Harz2018:SurveyLanguages}.

Some smart contract languages are expressive enough that they are used to define \emph{tokens}, which are new currencies with the associated code and data installed in ``user space'', rather than being specified by the ledger system itself. Awkwardly, although tokens can have many of the same features as the native currency, when they are defined separately they need special handling by user facing tool chains, to provide wallet interfaces, transaction listings and so on~\cite{Vogelsteller2015:ERC20}.

Besides user experience, there is often an expressivity gap between the support a ledger system provides for its native currencies, and what can be implemented for tokens. For example, in Ethereum the user code that defines a token typically stores balances for all token accounts in an array structure that is owned by a native Ethereum account. As token balances are stored in a user level structure, it is easy to perform \emph{global queries} over the data, such as to compute the total holdings of all accounts, or to find the account with the highest balance. On the other hand, in Ethereum does not provide a mechanism for contract code to perform the same queries over the balances of its own native currency. DAML is more homogeneous in the sense that assets are defined uniformly as user code, but the current version again does not support general queries over stored data, which we discuss further in \REF.

In contrast, FCL provides a high level contract programming model based on Colored Petri Nets~\cite{Jensen1981:ColouredPetri}. Petri Nets are related to \emph{production rule} frameworks such as OPS5~\cite{Forgy1981:OPS5} and CLIPS~\cite{Riley2017:CLIPS}, which are based around a store of facts, and set rules that match on existing facts and produce new facts. The fact matching process is fundamentally a query process, provided one views each \emph{place} in the Petri Net model as akin to an unordered \emph{table} in a database model. Petri Nets are expressive enough to implement production business workflows, with prior work demonstrating how to use Petri Nets as a compilation target for the standard Business Process Execution Language (BPEL)~\cite{Lohmann2009:PetriBPEL}.  However, as with Ethereum, the native asset system of FCL is baked into the language framework, rather than being user defined. We seek to unify these concerns: to allow assets to be defined uniformly as contract code, while supporting natural queries over the data.

\begin{itemize}
\item We present Rainfall, a programming model based on authorized production rules that allows mutually distrusting parties to manage assets on a distributed ledger. (\S\ref{s:FactsWeights})

\item The rules defining how assets are transferred can be specified directly in user code, without relying on primitive support for transfers provided by the language framework. (\S\ref{s:FactAuthority})

\item Our system naturally provides a \emph{privacy} model, where not all facts need to be revealed to all parties. This makes it easy for users add their own business rules. (\S\ref{s:Privacy})

\item Being based on a production rule framework, it is straightforward to define workflows that perform queries over all facts visible to some party. (\S\ref{s:Query})

% \item We also provide a straightforward upgrade path, where the parties using a set of rules and facts can vote to upgrade then to a new version.
\end{itemize}

The focus of our work is on the language semantics and authority mechanism, rather than the particular distributed consensus protocol, though we do cover details such as the intended transaction representation. In our case, ``contracts'' are programs that have an operational semantics sufficient for execution, rather than specifying constraints on the values produced by a function~\cite{Findler2002:Contracts}, messages exchanged in a protocol~\cite{Das2019:Resource, Deon2019:CSL}, or to provide prices for financial products~\cite{PeytonJones2000:Composing}, as in similarly named work.




