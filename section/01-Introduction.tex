
\section{Introduction}
Distributed ledgers allow information about virtual assets to be recorded and modified by mutually distrusting parties. A prime application of distributed ledgers is to implement cryptocurrencies such as Bitcoin, Dogecoin, Ethereum and so on. In such systems, some of the rules that specify how assets assets can be transferred between parties are baked into the ledger framework, while others can be defined in a programming language whose runtime is provided by the ledger system. Early systems such as Bitcoin used a sequence of simple, non-looping bytecodes to specify the requirements for coin transfer~\cite{Atzei2017:BitcoinTransactions}. Latter systems such as the Ethereum Virtual Machine (EVM)~\cite{Wood2014:Ethereum}, EOS.IO~\cite{Grigg2017:EosIntroduction}, Scilla~\cite{Sergey2018:Scilla}, Pact~\cite{Popejpy2016:Pact}, The Financial Core Language~(FCL)~\cite{Adjoint2019:FCL} and Plutus~\cite{IOHK2018:Plutus}, are more general purpose languages that can include looping, structured data and polymorphism. We refer to these languages as \emph{smart contract} languages, as the intended application is to express rules and workflows for managing financial assets~\cite{Harz2018:SurveyLanguages}.

Smart contract languages are often expressive enough that they are often used to define \emph{tokens}, which are new currencies where their associated code and data installed in ``user space'', rather than being specified by the ledger system itself. Awkwardly, although these tokens can have many of the same features as the native currency, as they are defined separately they need need special handling by the user facing tool chain to provide wallet and transaction listing and so on~\cite{Vogelsteller2015:ERC20}.

Besides user experience such as wallet interfaces, there is often an expressivity gap between the support a smart contract language provides for its native currencies, and what can be implemented for tokens. For example, in the Ethereum system, the user code that defines a token typically stores  the balances for all token accounts in an array structure that is owned by a native Ethereum account. As the token balances are stored in a user level structure, it is easy to perform \emph{global queries} over the data, such as to compute the total holdings of all accounts, or to find the account with the highest balance. On the other hand, in Ethereum it is not possible for contract code to perform the same queries over the balances of its own native currency, because the EVM does not include opcodes to scan through them all.

In contrast to low level bytecode languages, FCL provides a high level contract programming model based on Colored Petri Nets~\cite{Jensen1981:ColouredPetri}. Petri Nets are known to be expressive enough to implement production business workflows --- existing work demonstrates how to use Petri Nets as a compilation target for the standard Business Process Execution Language (BPEL)~\cite{Lohmann2009:PetriBPEL}. Petri Nets are also strongly related to \emph{production rule} frameworks such as OPS5~\cite{Forgy1981:OPS5} and CLIPS~\cite{Riley2017:CLIPS}, which are based around a store of facts, and set rules that match on existing facts and produce new facts. This fact matching process is fundamentally a query process, if one views each \emph{place} in the Petri Net model as akin to a \emph{table} in a database model. However, as with the situation in Ethereum, the native asset system of FCL is baked into the language framework, rather than being user defined. We seek to unify these concerns:

\begin{itemize}
\item We present Rainfall, a programming model based on authorized production rules that allows mutually distrusting parties to manage assets on a distributed ledger. (\S\ref{s:FactsWeights})

\item The rules defining how assets are transferred can be specified directly in user code, without relying on primitive support for transfers provided by the language framework. (\S\ref{s:FactAuthority})

\item Our authorization system naturally provides a \emph{privacy} model, where not all facts need to be revealed to all parties. This makes it easy for users add their own business rules. (\S\ref{s:Privacy})

\item Being based on a production rule framework, it is straightforward to define workflows that perform queries over all facts visible to some party. (\S\ref{s:Query})

% \item We also provide a straightforward upgrade path, where the parties using a set of rules and facts can vote to upgrade then to a new version.
\end{itemize}

The focus of our work is on the language semantics and authority mechanism. We do discuss aspects of the intended implementation, such as transaction representations, but our programming model is not specific to a particular distributed consensus protocol. In our case, ``contracts'' are programs that have an operational semantics sufficient for execution, rather than specifying constraints on the values produced by a function~\cite{Findler2002:Contracts}, messages exchanged in a protocol~\cite{Das2019:Resource, Deon2019:CSL}, or to provide prices for financial products~\cite{PeytonJones2000:Composing}, as in similarly named work.




