
\section{Introduction}
Distributed ledger systems allow information about virtual assets to recorded and modified by mutually distrusting parties. A prime application of distributed ledgers is to implement cryptocurrencies such as Bitcoin, Dogecoin, Ethereum and so on. In such systems, some of the rules about how their native assets can be transferred between parties using are baked into the ledger framework, while others can be defined in a programming language whose runtime is included in the ledger system implementation. Early systems such as Bitcoin used a sequence of simple, non-looping bytecodes to specify the requirements for coin transfer~\CITE. Latter systems such as the Ethereum Virtual Machine (EVM)~\CITE, EOS.IO~\CITE, Michaelson~\CITE, Pact~\CITE, FCL~\CITE and Plutus~\CITE, use more general purpose languages that can include looping, structured data and polymorphism. These languages are referred to as \emph{smart contract} languages, as the intended application is to express rules and workflows for managing financial assets.

The more recent languages are expressive enough that they are often used to define \emph{tokens}, which are new currencies where the code and data that specify how they work are installed in ``user space''. Awkwardly, these tokens exist separately from the native currency of the system, such as Bitcoin, Dogecoin and the like. As the tokens are defined separately, they need need special handling by the user facing tool chain to provide wallet and transaction listing and so on \CITE ERC-20.

Besides user experience such as wallet interfaces, there is often an expressivity gap between the support a smart contract language provides for its native currencies, and what can be implemented for tokens. For example, in the Ethereum system, the user code that defines a token typically stores  the balances for all token accounts in an array structure that is owned by a native Ethereum account. As the token balances are stored in a user level structure, it is easy to perform \emph{global queries} over the data, such as to compute the total holdings of all accounts, or to find the account with the highest balance. On the other hand, in Ethereum it is not possible for contract code to perform the same queries over the balances of its own native currency, because the EVM does not include opcodes to scan through them all.

In contrast to low level bytecode languages, FCL provides a high level contract programming model based on Colored Petri Nets \CITE. Petri Nets are known to be expressive enough to implement production business workflows --- existing work demonstrates how to use Petri Nets as a compilation target for the standard Business Process Execution Language (BPEL). Petri Nets are also strongly related to \emph{production rule} frameworks such as OPS5~\CITE and CLIPS~\CITE, which are based around a store of facts, and set rules that match on existing facts and produce new facts. This fact matching process is fundamentally a query process, if one views each \emph{place} in the Petri Net model as akin to a \emph{table} in a database model. However, as with the situation in Ethereum, the native asset system of FCL is baked into the language framework, rather than being user defined. Our own system, Rainfall, unifies these concerns:

\begin{itemize}
\item We present a system based on authorized production rules that allows mutually distrusting parties to manage assets on a distributed ledger. (\S\ref{s:FactsWeights})

\item The rules that define how assets are transferred can be specified directly in user code, without relying on primitive support for transfers provided by the language framework. (\S\ref{s:Authority})

\item Our authorization system naturally provides a \emph{privacy} model, where not all facts need to be revealed to all parties, which makes it easy for users add their own business rules. (\S\ref{s:Privacy})

\item Being based on a Petri Net model, it is straightforward to define workflows that perform global queries over all facts visible to some party. (\S\ref{s:Query})

% \item We also provide a straightforward upgrade path, where the parties using a set of rules and facts can vote to upgrade then to a new version.
\end{itemize}

The focus of our work is on the language semantics and authority mechanism. We do discuss aspects of the intended implementation, such as transaction representations, but our programming model is not specific to a particular distributed consensus protocol. In our case, ``contracts'' are programs that have an operational semantics sufficient for execution, rather than specifying constraints on a protocol, or prices for financial products, as in similarly named work.




