
\section{Introduction}
Distributed ledgers allow information about financial assets to be recorded and modified by mutually distrusting parties. A prime application is to manage cryptocurrencies such as Bitcoin, Dogecoin, Ethereum and so on. In such systems, some of the rules that specify how assets can be transferred between parties are baked into the ledger framework, while others can be defined in a programming language whose runtime is part of the ledger system. Early ledgers such as Bitcoin used a sequence of simple, non-looping bytecodes to specify the requirements for coin transfer~\cite{Atzei2017:BitcoinTransactions}. Latter systems use more general purpose languages such as the Ethereum Virtual Machine (EVM)~\cite{Wood2014:Ethereum}, EOS~\cite{Grigg2017:EosIntroduction}, Scilla~\cite{Sergey2018:Scilla}, Pact~\cite{Popejpy2016:Pact}, FCL~\cite{Adjoint2019:FCL}, Plutus~\cite{IOHK2018:Plutus} and DAML~\cite{DA2019:DAML}, which can include looping, structured data and polymorphism. We refer to these as \emph{smart contract} languages, as the intended application is to express the rules, workflows, rights and obligations involved in managing assets~\cite{Harz2018:SurveyLanguages}.

Most smart contract languages are expressive enough that they are used to define \emph{tokens}, which are new currencies separate from the native currency of the system (such as Bitcoin, Dogecoin and so on). The rules and data to define a token is typically installed in ``user space'' on the ledger, rather using builtin support for the native currency. Awkwardly, although tokens can have similar features to the native currency, when they are defined separately they need special handling by user facing tool chains --- to provide wallet interfaces, transaction listings and so on~\cite{Vogelsteller2015:ERC20}.

Besides user experience, there is often an expressivity gap between the support a distributed ledger system provides for its native currencies, and what can be implemented for tokens. For example, in account based~\cite{Zahnentferner2018:Chimeric} Ethereum, the user code that defines a token typically stores the balances for all token accounts in an array structure that is owned by a single native Ethereum account. As the token balances are stored in a user level structure, it is easy for a contract to perform queries over this data, such as to find the account with the highest balance. On the other hand, Ethereum does not provide a way for contract code to perform the same queries  over account balances of its own native currency, as this is not supported by the virtual machine the contract runs on. The Unspent Transaction Output (UTxO) based~\cite{Zahnentferner2018:UTxO} DAML is more homogeneous in that assets are defined uniformly as user code. However, the current version of DAML, somewhat inversely, does not support general queries over user data, which we discuss further in \S\ref{s:RelatedPermissioned}.

FCL provides an alternate programming model based on Colored Petri Nets~\cite{Jensen1981:ColouredPetri}. Petri nets are related to \emph{production rule} frameworks such as OPS5~\cite{Forgy1981:OPS5} and CLIPS~\cite{Riley2017:CLIPS}. A production rule watches a store of facts, waits for a particular set of matching facts to become available, and then produces new facts, possibly triggering other rules, and so on. This matching process is fundamentally a query process, like a relational join. Comparing with the Colored Petri Net model we can view a \emph{place} in the Petri net as an unordered \emph{table} in a database model. Petri nets and production rules are expressive enough to implement real business workflows, with prior work demonstrating how to use Petri nets as a compilation target for the standard Business Process Execution Language (BPEL)~\cite{Lohmann2009:PetriBPEL}.  However, although FCL is based on Petri nets, its native asset system is baked into the language framework, rather than being user defined. Our contribution is to unify these concerns:

% We seek to unify these concerns: to allow assets to be defined uniformly as user level contract code, while supporting natural queries over the data.

\begin{itemize}
\item We present Rainfall, a programming model based on authorized production rules that allows mutually distrusting parties to manage assets on a distributed ledger. (\S\ref{s:FactsWeights})

\item Rules defining how assets can be transferred are specified directly in user code, instead of requiring the programming model to provide primitive support for asset transfers. (\S\ref{s:FactAuthority})

\item Our production rule framework makes it straightforward to define workflows that perform queries over all facts visible to some party. (\S\ref{s:Query})

\item Our authorization system naturally extends to provide \emph{privacy}, so facts and rules do not need to be revealed to all parties using the system. (\S\ref{s:Privacy})

% \item We also provide a straightforward upgrade path, where the parties using a set of rules and facts can vote to upgrade then to a new version.
\end{itemize}

Our work focuses on the language semantics and authority mechanism, rather than details of the networking layer. However, we do mention cross cutting concerns such as the intended representation of transactions. In our case, ``contracts'' are executable programs, rather than constraints on the values produced by a function~\cite{Findler2002:Contracts}, messages exchanged in a protocol~\cite{Das2019:Resource, Deon2019:CSL}, or a way to compute prices of financial products~\cite{PeytonJones2000:Composing}, as in similarly named work.




