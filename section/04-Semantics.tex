
% -----------------------------------------------------------------------------
\section{Semantics}
The Rainfall semantics is defined in terms of a core language where pattern matching is expressed as set comprehension style generators. For expositional purposes we express rule bodies using a version of Simply Typed Lambda Calculus (STLC) with records and sets, but a production implementation could also use a more expressive language like System-F, or a well defined bytecode. The key ideas of our system are embodied in the rule structure and authority mechanism, while the language of rule bodies is arbitrary.


% -----------------------------------------------------------------------------
\begin{figure}
\begin{tabbing}
Mx \= MMMMx \= Mx \= MMM \= MMMM \kill
\\  $N,$ \> $Name$       \> ::= \> ...
\\  $L,$ \> $Label$      \> ::= \> ...
\\  $X,$ \> $Var$        \> ::= \> ...

\\[1ex]
    $R,$ \> $Rule$      \> ::= \> $\krule~ Name~ \kawait~ Match+~ \kto~ Term$
\\[0.5ex]
    $H,$ \> $Match$     \> ::= \> $Var~ \kfrom~ Name~ \kwhere~ Term$
\\      \>              \>     \> \hspace{1.6em}
                                  $\kselect~ Select~ \kconsume~ Consume~ \kgain~ Gain$
\\[0.5ex]
   $C,$ \> $Select$     \> ::= \> $\kany~ |~ \kfirst~ Term~ ~|~ \klast~ Term$
\\ $U,$ \> $Consume$    \> ::= \> $\knone~ |~ Term$
\\ $I,$ \> $Gain$       \> ::= \> $\knone~ |~ Term$

\\[1ex]
   $T,$ \> $Type$       \> ::= \> $\kUnit~ |~ \kBool~ |~ \kNat~ |~ \kText~ |~ \kSymbol~ |~ \kParty$
\\ \>                   \> ~|  \> $\kSet~ Type~ |~ \kFact~ Type~ |~ \kFactoid$
\\ \>                   \> ~|  \> $[ (Label : Type)* ] ~|~ Type \to Type~$

\\[1ex]
  $M,$   \> $Term$      \> ::= \> $Literal~ |~ Var~ |~ Term~ Term~ |~ \lambda Var : Type.~ Term$
\\ \>                   \> ~|  \> $[ (Label = Term)* ]~ |~ Term~ .~ Label ~|~ \{|~ Term* |\}$

\\[0.5ex] \>            \> ~|  \> $\ksay~ Name~ Term~$
\\        \>            \>     \> \hspace{0.5em} $\kby~ Term~ \kobs~ Term~ \kuse~ Term~ \knum~ Term$

\\[1ex]
  $V,$   \> $Value$     \> ::= \> $Literal~ |~ \lambda Var : Type.~ Term$
\\       \>             \> ~|  \> $[ (Label = Value)* ] ~|~ \{ Value* \}$
\\       \>             \> ~|  \> $Fact ~|~ (Fact, Weight)$

\\[1ex]
  $L,$   \> $Literal$   \> ::= \> $\kunit$ ~|~ $Bool$ ~|~ $Nat$ ~|~ $Text$ ~|~ $Symbol$ ~|~ $Party$
\end{tabbing}

\medskip
\begin{flushleft}
(primitive operators)
\end{flushleft}
\begin{tabbing}
MMMMMMMM \= Mx \= MMMMM \kill
   @fact'payload@$_T$ \> $:: @Fact@~ T \to T$
\\ @fact'by@$_T$      \> $:: @Fact@~ T \to \kSet~ \kParty$
\\ @fact'obs@$_T$     \> $:: @Fact@~ T \to \kSet~ \kParty$
\\ @fact'use@$_T$     \> $:: @Fact@~ T \to \kSet~ \kSymbol$
\end{tabbing}

\medskip
\begin{flushleft}
(environments)
\begin{tabbing}
Mx              \= MMMMMx       \= Mx \= MMMMMMM \kill
   $\Gamma,$       \> $Env$     \> ::= \> $\cdot ~|~ Env,~ Var : Type$
\\ $\Sigma,$       \> $Decls$   \> ::= \> $\cdot ~|~ Decls,~ Name : [(Label : Type)*]$
\end{tabbing}
\end{flushleft}

\caption{Core Language Grammar}
\label{f:Grammar}
\end{figure}


% -----------------------------------------------------------------------------
\begin{figure}
\begin{small}
\begin{alltt}
rule  Transfer                ** TODO make this match source.
await accept from Accept
       where true
       select any  consume 1 gain accept.accepter
 and  offer  from Offer
       where accept.id       == offer.id  &&
             accept.accepter == offer.receiver
       select any  consume 1 gain offer.giver
 and  coin   from Coin
       where coin.holder == offer.giver
       select any  consume 1 gain coin.issuer
to
    \{ say Coin [ stamp  = coin.stamp
               , holder = offer.receiver]
       by  \{ !Bank, offer.receiver \}  obs \{ !Mona \}
       use \{ 'Transfer \}              num 1) \}
\end{alltt}
\end{small}

\caption{Desugared Coin Transfer Rule}
\label{f:CoinTransferDesugared}
\end{figure}


% -----------------------------------------------------------------------------
\subsection{Grammar}
The grammar for the core language is in Figure~\ref{f:Grammar}, with a matching version of the coin transfer rule from Figure~\ref{f:CoinTransfer} given in Figure~\ref{f:CoinTransferDesugared}.
A $Rule$ has a name, pattern matching clauses, and a term for the body to produce a set of new factoids. We use EBNF, so $Match+$ in the production for $Rule$ means there must be at least one match clause. The matching clauses have the form:
$$
X~ @from@~ N~ @where@~ M~ @select@~ C~ @consume@~ U~ @gain@~ I
$$
This clause states that we should scan through all facts in the store with name $N$, binding each in turn to the variable $X$ which is in scope for the sub-terms in the clause. We then \emph{gather} all such facts that satisfy predicate $M$ into a set, \emph{select} the single fact specified by $C$, \emph{consume} the weight specified by $U$, and \emph{gain} the authority specified by $I$. In the select clause $C$, the @any@ keyword indicates that any gathered fact that satisfies the @where@ predicate can be selected. For $@first@~ M$ and $@last@~ M$ we sort facts by the key $M$ and take the first or last one. Our gather/select/consume/gain process is a regularized database query, reminiscent of the FLWOR blocks of XQuery~\cite{Boag2002:XQuery}. Join style queries are expressed using multiple fact matching patterns. We default previously elided @select@ and @consume@ clauses to @select any@ and @consume 1@ respectively.

In the term language we require a few primitive operators to split out the components of a fact value --- @fact'payload@ and so on. In Figure~\ref{f:CoinTransferDesugared}, however, we have left applications of @fact'payload@ implicit for readability, and retained some standard infix operators. The @check@ clauses used in \S\ref{s:Selection} can be desugared into applications of @fact'by@ that check the authority of a fact in a @where@ clause.


% -----------------------------------------------------------------------------
\eject{}
\subsection{Static Semantics}
Our type language is standard. In Figure~\ref{f:Grammar} the type ($@Fact@~ Type$) classifies fact values whose payload has type $Type$. The type @Factoid@ classifies factoid values which are written $(Fact, Weight)$. This type omits a parameter for the payload so that rule bodies can produce sets of factoids of differing sorts.

The typing rules are in Figure~\ref{f:Statics}. Most judgment forms use two environments: $Decls$ ($\Sigma$) which maps fact names to their payload types, and $Env$ ($\Gamma$) which maps variable names to their types. The grammar for the environment are back in Figure~\ref{f:Grammar}. In the source language example in Figure~\ref{f:CoinTransfer} we specified the payload type of each fact using the @fact@ keyword. In the static semantics here we assume all such types are added to the initial @Decls@ environment.

The judgment ($\jOk{\Sigma}{R}$) checks that rule $R$ is well typed. In the premises we check the sequence of pattern matches, producing a type environment $\Gamma$, that lists the types of variables that are in scope in the body of the rule. The body $M$ produces a set of new factoids. The judgment ($\jTypeMatch{\Sigma}{\Gamma}{X ; N ; M}{\Gamma'}$) checks the \emph{gather} part of the pattern match, where $X$ is bound to to each fact of name $N$ in turn, and we keep the facts that match the boolean predicate $M$. The premise $(N:T) \in \Sigma$ retrieves the payload type $T$ of the fact, which is used to construct the type of $X$ which is in scope in the rule body $M$. Checking of $Select$, $Consume$, $Gain$ and $Term$ expressions straightforward.


% -----------------------------------------------------------------------------
\input{figure/Static.tex}


% -----------------------------------------------------------------------------
\subsection{Dynamic Semantics}
The dynamic semantics is shown in Figure~\ref{f:Dynamics}. In the figure we use the abbreviation $Auth$ to mean a set of party values that currently authorize some action, $Facts$ to mean a \emph{set} of facts, $Factoid$ to mean a fact value paired with its weight, and $Factoids$ to mean a map of facts to their weights, which can alternatively be interpreted as a multiset. In the notation we indicate that a variable stands for a collection like a vector, set or multiset by including a superscript that indicates the size of that collection, so $F^n$ would stand for a set of facts with size $n$.

The semantics can be used to both execute rules to produce a transaction structure as shown in \REF, and also to validate that a transaction is well formed. The semantic rules are non-deterministic in the sense that given a store and a single rule definition, it may be possible to execute that rule by matching various subsets of facts, and the semantic rules do not specify which particular subset to use. As described in \REF, when a particular party submits a transaction, it is up to them to resolve the non-determinism as they see fit. Rainfall is specifically a \emph{contract system}, which specifies a range of valid behavior for a concurrent system, rather than an abstract machine that fixes a single order for rule firings.

Starting with the top-level EvFire rule, the judgment: \\
($\jFire{A_{sub}}{S}{R}{F^r_{read}}{D^s_{spend}}{D^n_{new}}{S'}$) says that a party with authority $A_{sub}$ and initial store $S$ can execute rule $R$, which reads facts $F^r_{read}$, spends factoids $D^s_{spend}$, creates new factoids $D^n_{new}$, producing a new store $S'$. The result sets can be used to produce (or check) a transaction structure, where the @spend@ list in the transaction is formed from both $F^r_{read}$ and $D^s_{spend}$, using zero valued weights for facts listed in $F^r_{read}$ which are read but not consumed.

The semantics is written from a global point of view, where the store includes the complete set of facts visible to all parties. The particular subset of facts visible to a submitting party is specified by $A_{sub}$. In the premises of EvFire, we apply the fact matches producing sets of read, and spent facts, along with the gained authority $A_{gain}$, which must cover the by-authority of all factoids $D^n_{new}$ produced by the body of the rule. The premise $\jStoreDown{S}{D^s_{spend}}{S'}$ checks that factoids needing to be spent are available in the store $S$ with sufficient weight, and then removes them from the store, producing a new store $S'$. Similarly $\jStoreUp{S}{D^n_{new}}{S''}$ adds the new facts produced by the rule body.

Rules EvMatchNil/Cons apply the match clauses to the store, collecting the set of facts read factoids spent, authority gained and the environment containing the matched facts. We use the $\uplus$ operator to mean multiset union, where the weights of identical facts are summed. Rule EvMatchOne applies a single match clause, performing the gather/select/consume/gain stages of the query in turn, producing the fact selected, the weight consumed, and any authority gained from that fact. We also check that name of the current rule is in the rule set of the fact. Note that if a fact is to be read but not consumed, the weight $W_{spend}$ will be zero. When the $(F,~ 0)$ factoid produced by EvMatch will be eliminated by the use of $\uplus$ in EvMatchCons, but the fact identifier $F$ will be retained in the set of facts read.

Rule EvGather collects the facts that match the gather predicate. The premise is written as a set comprehension, where the clause $\trm{sees}~ A_{sub}~ F$ ensures we only include facts visible to the submitting party. The $\trm{sees}$ predicate was defined back in \REF.

Rules EvAny/First specify how a single fact can be selected from the set of gathered facts. With EvAny any fact can be selected. EvFirst we first produce a set of pairs $D^m$ of sort keys and values, and select the value corresponding to the minimum sort key. Handling the @last@ keyword is just the reverse, and we elide the rule to save space.

Rule EvConsume just evaluates the term specifying the fact weight to be consumed. We check that a fact of this weight is actually available back in EvFire before removing the set of spent facts from the store. Rule EvGain evaluates the term specifying the authority to be gained from the selected fact, and also checks the fact can actually provide that authority.

Rule EvSay simply evaluates its arguments and produces the corresponding factoid. The remaining rules to evaluate the STLC term language are standard and have been omitted to save space.

Finally, as our match clauses are evaluated sequentially in EvMatchNil/Cons, and EvGather uses a set comprehension, our semantics embeds the computation of a relational join between fact sets. A direct implementation of the fact matching semantics would be equivalent to using naive cartesian product and filtering to perform the join, rather than using a more efficient indexing mechanism. A production that monitors the store and determines when rules can fire could perhaps implement the semantics using the RETE algorithm~\cite{Forgy1981:RETE, Doorenbos1995:ProductionMatching}, a parallel extension of it~\cite{Aref1998:LanaMatch}, or by conversion onto relational algebra for execution on a back-end relational database.
\input{figure/Dynamic.tex}



% -----------------------------------------------------------------------------
\eject{}
\subsection{Properties}

We have formalised Rainfall in the Isabelle interactive theorem prover, and proved several isolation and authorisation properties of the dynamic semantics.
The following theorem states that execution of a rule can only depend on the facts explicitly used by the rule:

% \AMOS{These lemmas are boring, I think. The second is used in the proof of frame constriction.}
% \begin{lemma}
% New facts are included in the new store (trivial):
% $$
% \jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
% \implies
% D_{new}^m \subseteq S'
% $$
% \end{lemma}
% (Using the $\subseteq$ notation to refer to the multiset subset operation here -- would it be better to unroll it as something like $\forall (x,w) \in D_{new}^m.\ (x,w') \in S' \wedge w \le w'$ ?)
%
% \begin{lemma}
% Rules only spend and read values from the store:
% $$
% \begin{array}{c}
% \jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
% \implies \\
% F_{read}^r ~\Cup~ D_{spent}^n \subseteq S
% \end{array}
% $$
% \end{lemma}

\begin{theorem}
Frame constriction:
$$
\begin{array}{c}
\jFire{A}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\quad \jFire{A}{F_{read}^r \Cup D_{spent}^n}{R}{F_{read}^r}{D_{spent}^n}{D'}{S'} \quad
\\[1ex]
\multicolumn{1}{l}{ \texttt{where } D' ~=~ D_{new}^m \uplus (F_{read}^r - D_{spent}^n)}
\\
\end{array}
$$
\end{theorem}

This theorem has the hypothesis that the rule $R$ executes in store $S$, reading the facts $F_{read}^r$ and spending the facts $D_{spent}^n$, and resulting in the new facts $D_{new}^m$.
Executing the same rule in a restricted environment that contains only the read and spent facts will create the same new facts.
For the restricted environment, we use the $\Cup$ operator to union with the maximum weight of each fact, as facts that exist in both the read set and spent multiset should not be counted twice.
In the original execution, the updated store $S'$ contains the original store without the spent facts and with the new facts; in the restricted environment, the new store $D'$ contains the new facts as well as the unspent read facts.


The following two theorems state that execution can only depend upon facts visible to the submitter:

\begin{theorem}
Spend and read only visible:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\forall f \in F_{read}^r \Cup D_{spent}^n.\ \trm{sees}~ A_{sub}~ f
\end{array}
$$
\end{theorem}

\begin{theorem}
Store weakening with invisible facts: adding facts that are not visible to the submitter does not affect execution:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\forall f \in S_{others}.\ \neg (\trm{sees}~ A_{sub}~ f)
\implies \\
\jFire{A_{sub}}{S \uplus S_{others}}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}

The following theorem states that all authority used to create new facts must be gained from the matched facts.
The submitter's authority only affects which facts are visible, but the submitter's authority is not necessarily added to created facts:

\begin{theorem}
Authority comes from facts:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\forall f \in D_{new}^m.\ \forall a \in \trm{auth-by}~f.\ \exists d \in F_{read}^r \Cup D_{spent}^n.\ a \in \trm{auth-by}~d
\end{array}
$$
\end{theorem}

The following two theorems state that, for rules containing only `any' selectors, new facts and authorities can be added without changing the execution.
For programs containing `first' selectors, adding new facts, or making new facts visible, could change the minimum value selected by `first'.

\begin{theorem}
Store weakening for `any' selectors:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\trm{rule-contains-only-any}~R \implies \\
\jFire{A_{sub}}{S \uplus S_{others}}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}

\begin{theorem}
More permissions for `any' selectors:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\trm{rule-contains-only-any}~R \implies \\
\jFire{A_{sub} \cup A_{others}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}

\eject

