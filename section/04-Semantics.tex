
\clearpage{}
% -----------------------------------------------------------------------------
\section{Semantics}
The Rainfall semantics is specified in terms of a core language where pattern matching is desugared into set comprehension like generators, and we use a version of Simply Typed Lambda Calculus (STLC) for the rule bodies. We STLC for expositional purposes, though in a production implementation it may be preferable to define rule bodies using a more expressive term language such as a version System-F, or as a well defined bytecode. The key ideas of our system are embodied in the overall rule structure and authority mechanism, and are not specific to the language used for rule bodies.

% -----------------------------------------------------------------------------
\subsection{Grammar}
The grammar for the core language is in Figure~\ref{f:Grammar}, with a matching version of the coin transfer rule from Figure~\ref{f:CoinTransfer} given in Figure~\ref{f:CoinTransferDesugared}.
$Rule$ has a name, list of matching clauses and a term for the body that produces a set of new factoids. We use EBNF, so $Match+$ in the production for $Rule$ means there must be at least one match clause. Fact matching is desugared into a sequence of clauses of the form:
$$
X~ @from@~ N~ @where@~ M~ @select@~ Select~ @consume@~ M'~ @gain@~ M''
$$
This clauses states that we should scan through all facts in the store with name $N$, binding each in turn to the variable $X$ which is in scope for the sub-terms in the clause. We then \emph{gather} all such facts that satisfy predicate $M$ into a set, \emph{select} a single fact according to the $Select$ specifier, \emph{consume} the weight specified by $M'$ from the store, and \emph{gain} the authority specified by $M''$. In the $Select$ clause, @any@ indicates that any gathered that satisfies the @where@ predicate in the matching clause can be selected. For $@first@~ M$ and $@last@~ M$ we sort the facts by the key value $M$ and take the first or last one.

The gather/select/consume/gain process is a regularized database query, reminiscent to the FLWOR blocks of XQuery~\cite{Boag2002:XQuery}. The pattern binders like @?i@ and @?a@ that were used in the source code of Figure~\ref{f:CoinTransfer} have been expressed with simple predicates in the desugared version in Figure~\ref{f:CoinTransferDesugared}. We default the preciously elided @select@ and @consume@ clauses to @select any@ and @consume 1@ respectively.

The basis for the $Type$ and $Term$ grammars is STLC with records. Our only non-standard extension is the @say@ form which constructs a new fact value, much like a data constructor. We also include a few primitive operators to split out the components of a fact value, taking the @fact'payload@ and so on. In Figure~\ref{f:CoinTransferDesugared} we have also used some additional primitive operators for equality, boolean logic, and retained the sugared set literals. We also leave applications of the @fact'payload@ primitive implicit when retrieving fields from fact values. If @f@ is a fact whose payload has type $\tau$, and $\tau$ is a record type that includes a field with label @x@, then we just write @f.x@ instead of @(fact'payload@$_\tau$ @f).x@

\TODO{describe Fact and Factoid types, and $(Fact, Weight)$} factoid form.


% -----------------------------------------------------------------------------
\begin{figure}
\begin{tabbing}
Mx \= MMMMx \= Mx \= MMM \= MMMM \kill
\\ $N,$ \> $Name$       \> ::= \> ...
\\ $L,$ \> $Label$      \> ::= \> ...
\\ $X,$ \> $Var$        \> ::= \> ...

\\[1ex]
  $R,$ \> $Rule$       \> ::= \> $\krule~ Name~ \kawait~ Match+~ \kto~ Term$
\\[0.5ex]
  $H,$ \> $Match$      \> ::= \> $Var~ \kfrom~ Name~ \kwhere~ Term$
\\      \>              \>     \> \hspace{1.6em} $\kselect~ Select~ \kconsume~ Term~ \kgain~ Term$
\\[0.5ex]
  $C,$ \> $Select$     \> ::= \> $\kany~ |~ \kfirst~ Term~ ~|~ \klast~ Term$

\\[1ex]
   $T,$ \> $Type$       \> ::= \> $\kUnit~ |~ \kBool~ |~ \kNat~ |~ \kText~ |~ \kSymbol~ |~ \kParty$
\\ \>                   \> ~|  \> $\kSet~ Type~ |~ \kFact~ Type~ |~ \kFactoid$
\\ \>                   \> ~|  \> $[ (Label : Type)* ] ~|~ Type \to Type~$

\\[1ex]
  $M,$   \> $Term$      \> ::= \> $Literal~ |~ Var~ |~ Term~ Term~ |~ \lambda Var : Type.~ Term$
\\ \>                   \> ~|  \> $[ (Label = Term)* ]~ |~ Term~ .~ Label ~|~ \{ Term* \}$

\\[0.5ex] \>            \> ~|  \> $\ksay~ Name~ Term~$
\\        \>            \>     \> \hspace{0.5em} $\kby~ Term~ \kobs~ Term~ \kuse~ Term~ \knum~ Term$

\\[1ex]
  $V,$   \> $Value$     \> ::= \> $Literal~ |~ \lambda Var : Type.~ Term$
\\       \>             \> ~|  \> $[ (Label = Value)* ] ~|~ \{ Value* \}$
\\       \>             \> ~|  \> $Fact ~|~ (Fact, Weight)$

\\[1ex]
  $L,$   \> $Literal$   \> ::= \> $\kunit$ ~|~ $Bool$ ~|~ $Nat$ ~|~ $Text$ ~|~ $Symbol$ ~|~ $Party$
\end{tabbing}

\medskip
\begin{flushleft}
(primitive operators)
\end{flushleft}
\begin{tabbing}
MMMMMMMM \= Mx \= MMMMM \kill
   @fact'payload@$_T$ \> $:: @Fact@~ T \to T$
\\ @fact'by@$_T$      \> $:: @Fact@~ T \to \kSet~ \kParty$
\\ @fact'obs@$_T$     \> $:: @Fact@~ T \to \kSet~ \kParty$
\\ @fact'use@$_T$     \> $:: @Fact@~ T \to \kSet~ \kSymbol$
\\ @fact'num@$_T$     \> $:: @Fact@~ T \to \kNat$
\end{tabbing}

% \medskip
% \begin{flushleft}
% (syntactic sugar)
% \end{flushleft}
% $$
% \begin{array}{cc}
%    \kretain \stackrel{\triangle}{=} \kconsume~ 0
% \quad & \quad
%    \ksame   \stackrel{\triangle}{=} \kgain~ \emptyset
% \end{array}
% $$

\medskip
\begin{flushleft}
(environments)
\begin{tabbing}
Mx              \= MMMMMx       \= Mx \= MMMMMMM \kill
   $\Gamma,$       \> $Env$     \> ::= \> $\cdot ~|~ Env,~ Var : Type$
\\ $\Sigma,$       \> $Decls$   \> ::= \> $\cdot ~|~ Decls,~ Name : [(Label : Type)*]$
\end{tabbing}
\end{flushleft}

\caption{Core Language Grammar}
\label{f:Grammar}
\end{figure}



% -----------------------------------------------------------------------------
\begin{figure}
\begin{small}
\begin{alltt}
rule  Transfer
await accept from Accept
       where true
       select any  consume 1  gain accept.accepter
 and  offer  from Offer
       where accept.id       == offer.id  &&
             accept.accepter == offer.receiver
       select any  consume 1  gain offer.giver
 and  coin   from Coin
       where coin.holder == offer.giver
       select any  consume 1  gain coin.issuer
to
    \{ say Coin [ stamp  = coin.stamp
               , holder = offer.receiver]
       by  \{ !Bank, offer.receiver \}  obs \{ \}
       use \{ 'Transfer \}              num 1) \}
\end{alltt}
\end{small}

\caption{Desugared Coin Transfer Rule}
\label{f:CoinTransferDesugared}
\end{figure}



% -----------------------------------------------------------------------------
\clearpage{}
\input{figure/Static.tex}

\subsection{Static Semantics}
The static semantics is shown in Figure~\ref{f:Statics}. Most judgment forms used two environments: $Decls$ ($\Sigma$) which maps fact names to their payload types, and $Env$ ($\Gamma$) which maps variable names to their types. The grammar for the environments is given back in Figure~\ref{f:Grammar}. In the source language example in Figure~\ref{f:CoinTransfer} we specified the payload type of each fact using the @fact@ keyword, though in the static semantics here we assume all such types are added to the @Decls@ environment before checking each rule.

The judgment ($\jOk{\Sigma}{R}$) checks that rule $R$ is well typed. In the premises we check the sequence of pattern matches, producing a type environment $\Gamma$, that specifies the types of variables that are in scope in the body of the rule. The body $M$ produces a set of weighted facts that are to be added to the store. The judgment $(\jTypeMatch{\Sigma}{\Gamma}{H^n}{\Gamma'})$ checks the sequence of pattern matches $H^n$, the following judgment form a single pattern match. The judgment ($\jTypeMatch{\Sigma}{\Gamma}{X ~;~ N ~;~ M}{\Gamma'}$) is used to check the \emph{gather} part of the pattern match, where $X$ is bound to to each fact of name $N$ in turn, and we keep the facts that match the boolean predicate $M$. The premise $(N:T) \in \Sigma$ retrieves the payload type $T$ of the fact, which is used to construct the type of $X$ which is in scope in the rule body $M$. Checking of $Select$ constructs and body terms is straightforward. The @say@ construct produces a value of the opaque @Factoid@ type so that weighted facts with different payload types can be collected into the same set.


% -----------------------------------------------------------------------------
\subsection{Dynamic Semantics}
The dynamic semantics is shown in Figure~\ref{f:Dynamics}. In the figure we use the abbreviation $Auth$ to mean a set of party values that currently authorize some action, $Facts$ to mean a \emph{set} of facts, $Factoid$ to mean a fact value paired with its weight, and $Factoids$ to mean a map of facts to their weights, which can alternatively be interpreted as a multiset. In the notation we indicate that a variable stands for a collection like a vector, set or multiset by including a superscript that indicates the size of that collection, so $F^n$ would stand for a set of facts with size $n$.

The semantics can be used to both execute rules to produce a transaction structure as shown in \REF, and also to validate that a transaction is well formed. The semantic rules are non-deterministic in the sense that given a store and a single rule definition, it may be possible to execute that rule by matching various subsets of facts, and the semantic rules do not specify which particular subset to use. As described in \REF, when a particular party submits a transaction, it is up to them to resolve the non-determinism as they see fit. Rainfall is specifically a \emph{contract system}, which specifies a range of valid behavior for a concurrent system, rather than an abstract machine that fixes a single order for rule firings.

Starting with the top-level EvFire rule, the judgment: \\
($\jFire{A_{sub}}{S}{R}{F^r_{read}}{D^s_{spend}}{D^n_{new}}{S'}$) says that a party with authority $A_{sub}$ and initial store $S$ can execute rule $R$, which reads facts $F^r_{read}$, spends factoids $D^s_{spend}$, creates new factoids $D^n_{new}$, producing a new store $S'$. The result sets can be used to produce (or check) a transaction structure, where the @spend@ list in the transaction is formed from both $F^r_{read}$ and $D^s_{spend}$, using zero valued weights for facts listed in $F^r_{read}$ which are read but not consumed.

The semantics is written from a global point of view, where the store includes the complete set of facts visible to all parties. The particular subset of facts visible to a submitting party is specified by $A_{sub}$. In the premises of EvFire, we apply the fact matches producing sets of read, and spent facts, along with the gained authority $A_{gain}$, which must cover the by-authority of all factoids $D^n_{new}$ produced by the body of the rule. The premise $\jStoreDown{S}{D^s_{spend}}{S'}$ checks that factoids needing to be spent are available in the store $S$ with sufficient weight, and then removes them from the store, producing a new store $S'$. Similarly $\jStoreUp{S}{D^n_{new}}{S''}$ adds the new facts produced by the rule body.

Rules EvMatchNil/Cons apply the match clauses to the store, collecting the set of facts read factoids spent, authority gained and the environment containing the matched facts. We use the $\uplus$ operator to mean multiset union, where the weights of identical facts are summed. Rule EvMatchOne applies a single match clause, performing the gather/select/consume/gain stages of the query in turn, producing the fact selected, the weight consumed, and any authority gained from that fact. We also check that name of the current rule is in the rule set of the fact. Note that if a fact is to be read but not consumed, the weight $W_{spend}$ will be zero. When the $(F,~ 0)$ factoid produced by EvMatch will be eliminated by the use of $\uplus$ in EvMatchCons, but the fact identifier $F$ will be retained in the set of facts read.

Rule EvGather collects the facts that match the gather predicate. The premise is written as a set comprehension, where the clause $\trm{sees}~ A_{sub}~ F$ ensures we only include facts visible to the submitting party. The $\trm{sees}$ predicate was defined back in \REF.

Rules EvAny/First specify how a single fact can be selected from the set of gathered facts. With EvAny any fact can be selected. EvFirst we first produce a set of pairs $D^m$ of sort keys and values, and select the value corresponding to the minimum sort key. Handling the @last@ keyword is just the reverse, and we elide the rule to save space.

Rule EvConsume just evaluates the term specifying the fact weight to be consumed. We check that a fact of this weight is actually available back in EvFire before removing the set of spent facts from the store. Rule EvGain evaluates the term specifying the authority to be gained from the selected fact, and also checks the fact can actually provide that authority.

Rule EvSay simply evaluates its arguments and produces the corresponding factoid. The remaining rules to evaluate the STLC term language are standard and have been omitted to save space.

Finally, as our match clauses are evaluated sequentially in EvMatchNil/Cons, and EvGather uses a set comprehension, our semantics embeds the computation of a relational join between fact sets. A direct implementation of the fact matching semantics would be equivalent to using naive cartesian product and filtering to perform the join, rather than using a more efficient indexing mechanism. A production that monitors the store and determines when rules can fire could perhaps implement the semantics using the RETE algorithm~\cite{Forgy1981:RETE, Doorenbos1995:ProductionMatching}, a parallel extension of it~\cite{Aref1998:LanaMatch}, or by conversion onto relational algebra for execution on a back-end relational database.
\input{figure/Dynamic.tex}



% -----------------------------------------------------------------------------
\eject{}
\subsection{Properties}

\AMOS{The following lemmas have been proved for a subset of the semantics without `retain' semantics}

\begin{lemma}
New facts are included in the new store (trivial):
$$
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies
D_{new}^m \subseteq S'
$$
\end{lemma}
(Using the $\subseteq$ notation to refer to the multiset subset operation here -- would it be better to unroll it as something like $\forall (x,w) \in D_{new}^m.\ (x,w') \in S' \wedge w \le w'$ ?)

\begin{lemma}
Rules only spend what is in the store (pretty trivial):
$$
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies
D_{spent}^n \subseteq S
$$
\end{lemma}

\begin{theorem}
Frame constriction: if a rule succeeds, the rule would succeed, resulting in the same value, in a store containing only what it spent:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\jFire{A_{sub}}{D_{spent}^n}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}
This theorem statement isn't quite correct at the moment, because it's ignoring retained/non-consumed values. I will update this rule to find the non-consumed values in the spent facts and copy them from the original store after I have updated the formalisation. I think updating the formalisation will expose some other lemmas.

\begin{theorem}
Spend only visible: execution can only spend facts visible to the submitter:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\forall f \in D_{spent}^n.\ \trm{sees}~ A_{sub}~ f
\end{array}
$$
\end{theorem}

\begin{theorem}
Store weakening with invisible facts: adding facts that are not visible to the submitter does not affect execution:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\forall f \in S_{others}.\ \neg (\trm{sees}~ A_{sub}~ f)
\implies \\
\jFire{A_{sub}}{S \uplus S_{others}}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}

\begin{theorem}
All authority in new facts is gained from spent facts:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\forall f \in D_{new}^m.\ \forall a \in \trm{auth-by}~f.\ \exists d \in D_{spent}^n.\ a \in \trm{auth-by}~d
\end{array}
$$
\end{theorem}

\AMOS{I haven't proved the following yet.}
The following theorems do not hold for all programs, but do hold for subsets.

\begin{theorem}
Store weakening for `any' selectors: if the rule doesn't contain any `first' selectors, we can add new facts without changing the execution:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\trm{rule-contains-only-any}~R \implies \\
\jFire{A_{sub}}{S \uplus S_{others}}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}

This theorem doesn't hold for `first' selectors because adding new values to the store might change the minimum, and so change which value the first selector chooses.

\begin{theorem}
More permissions do not change behaviour of `any' selectors: if the rule doesn't contain any `first' selectors, we can add new authority without changing the execution:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\trm{rule-contains-only-any}~R \implies \\
\jFire{A_{sub} \cup A_{others}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}

