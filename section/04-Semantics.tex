
% -----------------------------------------------------------------------------
\section{Semantics}
The Rainfall semantics is defined in terms of a core language where pattern matching is expressed as set comprehension style generators. For expositional purposes we express rule bodies using a version of Simply Typed Lambda Calculus (STLC) with records and sets, but a production implementation could also use a more expressive language like System-F, or a well defined bytecode. The key ideas of our system are embodied in the rule structure and authority mechanism, while the language of rule bodies is arbitrary.


% -----------------------------------------------------------------------------
\begin{figure}
\begin{tabbing}
Mx \= MMMMx \= Mx \= MMM \= MMMM \kill
\\  $N,$ \> $Name$       \> ::= \> ...
\\  $L,$ \> $Label$      \> ::= \> ...
\\  $X,$ \> $Var$        \> ::= \> ...

\\[1ex]
    $R,$ \> $Rule$      \> ::= \> $\krule~ Name~ \kawait~ Match+~ \kto~ Term$
\\[0.5ex]
    $H,$ \> $Match$     \> ::= \> $Var~ \kfrom~ Name~ \kwhere~ Term$
\\      \>              \>     \> \hspace{1.6em}
                                  $\kselect~ Select~ \kconsume~ Consume~ \kgain~ Gain$
\\[0.5ex]
   $C,$ \> $Select$     \> ::= \> $\kany~ |~ \kfirst~ Term~ ~|~ \klast~ Term$
\\ $U,$ \> $Consume$    \> ::= \> $\knone~ |~ Term$
\\ $I,$ \> $Gain$       \> ::= \> $\knone~ |~ Term$

\\[1ex]
   $T,$ \> $Type$       \> ::= \> $\kUnit~ |~ \kBool~ |~ \kNat~ |~ \kText~ |~ \kSymbol~ |~ \kParty$
\\ \>                   \> ~|  \> $\kSet~ Type~ |~ \kFact~ Type~ |~ \kFactoid$
\\ \>                   \> ~|  \> $[ (Label : Type)* ] ~|~ Type \to Type~$

\\[1ex]
  $M,$   \> $Term$      \> ::= \> $Literal~ |~ Var~ |~ Term~ Term~ |~ \lambda Var : Type.~ Term$
\\ \>                   \> ~|  \> $[ (Label = Term)* ]~ |~ Term~ .~ Label ~|~ \{|~ Term* |\}$

\\[0.5ex] \>            \> ~|  \> $\ksay~ Name~ Term~$
\\        \>            \>     \> \hspace{0.5em} $\kby~ Term~ \kobs~ Term~ \kuse~ Term~ \knum~ Term$

\\[1ex]
  $V,$   \> $Value$     \> ::= \> $Literal~ |~ \lambda Var : Type.~ Term$
\\       \>             \> ~|  \> $[ (Label = Value)* ] ~|~ \{ Value* \}$
\\       \>             \> ~|  \> $Fact ~|~ (Fact, Weight)$

\\[1ex]
  $L,$   \> $Literal$   \> ::= \> $\kunit$ ~|~ $Bool$ ~|~ $Nat$ ~|~ $Text$ ~|~ $Symbol$ ~|~ $Party$
\end{tabbing}

\medskip
\begin{flushleft}
(primitive operators)
\end{flushleft}
\begin{tabbing}
MMMMMMMM \= Mx \= MMMMM \kill
   @fact'payload@$_T$ \> $:: @Fact@~ T \to T$
\\ @fact'by@$_T$      \> $:: @Fact@~ T \to \kSet~ \kParty$
\\ @fact'obs@$_T$     \> $:: @Fact@~ T \to \kSet~ \kParty$
\\ @fact'use@$_T$     \> $:: @Fact@~ T \to \kSet~ \kSymbol$
\end{tabbing}

\medskip
\begin{flushleft}
(environments)
\begin{tabbing}
Mx              \= MMMMMx       \= Mx \= MMMMMMM \kill
   $\Gamma,$       \> $Env$     \> ::= \> $\cdot ~|~ Env,~ Var : Type$
\\ $\Sigma,$       \> $Decls$   \> ::= \> $\cdot ~|~ Decls,~ Name : [(Label : Type)*]$
\end{tabbing}
\end{flushleft}

\caption{Core Language Grammar}
\label{f:Grammar}
\end{figure}


% -----------------------------------------------------------------------------
\begin{figure}
\begin{small}
\begin{alltt}
rule  transfer
await offer  from Offer
       where true
       select any  consume 1  gain \{offer.giver\}
 and  accept from Accept
       where accept.id       == offer.id &&
             accept.accepter == offer.receiver
       select any  consume 1  gain \{offer.receiver\}
 and  coin   from Coin
       where coin.issuer     == !Isabelle &&
             coin.holder     == offer.receiver
       select any  consume 1  gain \{!Isabelle, offer.giver\}
to \{
     say Coin [ issuer = !Isabelle
              , holder = offer.receiver ]
      by  \{!Isabelle,offer.receiver\}  obs \{!Mona\}
      use \{'transfer\}                 num 1
   \}
\end{alltt}
\end{small}

\caption{Desugared Coin Transfer Rule}
\label{f:CoinTransferDesugared}
\end{figure}


% -----------------------------------------------------------------------------
\subsection{Grammar}
The grammar for the core language is in Figure~\ref{f:Grammar}. A matching desugared version of the coin transfer rule from Figure~\ref{f:CoinTransfer}, using @!Mona@ as an observer, is in Figure~\ref{f:CoinTransferDesugared}.
A $Rule$ has a name, pattern matching clauses, and a term for the body to produce a set of new factoids. We use EBNF, so $Match+$ in the production for $Rule$ requires at least one match clause. Each $Match$ clause has form:
$$
X~ @from@~ N~ @where@~ M~ @select@~ C~ @consume@~ U~ @gain@~ I
$$
This says we should scan through all facts in the store with name $N$, binding each in turn to the variable $X$ which is in scope for the sub-terms in the clause. We then \emph{gather} all such facts that satisfy predicate $M$ into a set, \emph{select} the single fact specified by $C$, \emph{consume} the weight specified by $U$, and \emph{gain} the authority specified by $I$. In the select clause $C$, the @any@ keyword indicates that any gathered fact that satisfies the @where@ predicate can be selected. For $@first@~ M$ and $@last@~ M$ we sort facts by the key $M$ and take the first or last one. Our gather/select/consume/gain process is a regularized database query, reminiscent of the FLWOR blocks of XQuery~\cite{Boag2002:XQuery}. Join style queries are expressed using multiple fact matching patterns. We default previously elided @select@, @consume@ and @gain@ clauses to @select any@, @consume 1@ and @gain {}@ respectively.

In the term language we require a few primitive operators to split out the components of a fact value --- @fact'payload@ and so on. In Figure~\ref{f:CoinTransferDesugared}, however, we have left applications of @fact'payload@ implicit for readability, and retained some standard infix operators. The @check@ clauses used in \S\ref{s:Selection} can be desugared into applications of @fact'by@ that check the authority of a fact in a @where@ clause.


% -----------------------------------------------------------------------------
\eject{}
\subsection{Static Semantics}
Our type language is standard. In Figure~\ref{f:Grammar} the type ($@Fact@~ Type$) classifies fact values whose payload has type $Type$. The type @Factoid@ classifies factoid values which are written $(Fact, Weight)$. This type omits a parameter for the payload so that rule bodies can produce sets of factoids of differing sorts.

The typing rules are in Figure~\ref{f:Statics}. Most judgment forms use two environments: $Decls$ ($\Sigma$) which maps fact names to their payload types, and $Env$ ($\Gamma$) which maps variable names to their types. The grammar for the environment are back in Figure~\ref{f:Grammar}. In the source language example in Figure~\ref{f:CoinTransfer} we specified the payload type of each fact using the @fact@ keyword. In the static semantics here we assume all such types are added to the initial @Decls@ environment.

The judgment ($\jOk{\Sigma}{R}$) checks that rule $R$ is well typed. In the premises we check the sequence of pattern matches, producing a type environment $\Gamma$, that lists the types of variables that are in scope in the body of the rule. The body $M$ produces a set of new factoids. The judgment ($\jTypeMatch{\Sigma}{\Gamma}{X ; N ; M}{\Gamma'}$) checks the \emph{gather} part of the pattern match, where $X$ is bound to to each fact of name $N$ in turn, and we keep the facts that match the boolean predicate $M$. The premise $(N:T) \in \Sigma$ retrieves the payload type $T$ of the fact, which is used to construct the type of $X$ which is in scope in the rule body $M$. Checking of $Select$, $Consume$, $Gain$ and $Term$ expressions straightforward.


% -----------------------------------------------------------------------------
\input{figure/Static.tex}


% -----------------------------------------------------------------------------
\subsection{Dynamic Semantics}
The evaluation rules are in Figure~\ref{f:Dynamics}. We use the abbreviation $Auth$ to mean a set of party values that authorize some fact, $Facts$ to mean a set of facts and $Factoids$ a map of facts to their weights. We use $Store$ to also map facts to their weights, but name it differently to hint that this is the current ledger state used for rule evaluation. We use $Env$ to map variable names to their values. In the notation we indicate that a variable stands for a collection by including a superscript that indicates the size of that collection, so $F^n$ would stand for a set of facts with size $n$.

This semantics can be used to both execute rules to produce a transaction as per~\S\ref{s:Transactions}, and also to validate that a transaction is well formed. The semantic rules are non-deterministic. Given a particular store and production rule definition, it may be possible to execute that production rule by matching several different subsets of facts, and the semantic rules do not specify which particular subset to use. When a particular party builds a transaction and submits the views to others, it is up to them to resolve any  non-determinism as they see fit. Rainfall is also a \emph{contract system} in the sense of specifying a range of valid behavior, rather than an abstract machine that fixes a single order for rule evaluation.

In Figure~\ref{f:Dynamics}, starting with the top-level EvFire rule, the judgment: \\
($\jFire{A_{sub}}{S}{R}{F^r_{read}}{D^s_{spend}}{D^n_{new}}{S'}$) says that a submitting party with authority $A_{sub}$ and initial store $S$ can execute rule $R$, which reads facts $F^r_{read}$, spends factoids $D^s_{spend}$, creates new factoids $D^n_{new}$, producing a new store $S'$. The result sets can be used to produce (or check) a transaction structure, where the input list in the transaction is formed from both $F^r_{read}$ and $D^s_{spend}$, using zero valued weights for facts listed in $F^r_{read}$ which are read but not consumed.

The semantics is specified from a global point of view, where the $Store$ includes the complete set of factoids visible to all parties. The particular subset of facts visible to a submitting party is controlled by $A_{sub}$, which is the authority of that party. In the premises of EvFire, we apply the pattern matches to produce a set of read, and spent fact, along with the gained authority $A_{gain}$, which must cover the by-authority of all new factoids $D^n_{new}$ produced by the body of the rule. The premise $\jStoreDown{S}{D^s_{spend}}{S'}$ checks that factoids needing to be spent are available in the store $S$ with sufficient weight, and then removes them from the store, producing a new store $S'$. Similarly $\jStoreUp{S}{D^n_{new}}{S''}$ adds the new facts produced by the rule body. The corresponding rules are in Figure~\ref{f:StoreModification}.

Rules EvMatchNil/Cons apply the pattern matches to the store, gathering the set of facts read factoids spent, authority gained and the environment containing the matched facts. We use $\uplus$ operator to mean multiset union, where the weights of identical facts are summed. Rule EvMatchOne performs a single pattern match, performing the gather/select/consume/gain stages to produce the fact selected, a factoid also mentioning the weight consumed, and the authority gained from that fact. If a fact is to be read but not consumed then the weight $W_{spend}$ will be zero. The $(F,~ 0)$ factoid produced by EvMatch will be eliminated by the use of $\uplus$ in EvMatchCons, but the fact $F$ will be retained in the set of facts read.

Rule EvGather collects the facts that match the gather predicate. The premise is written as a set comprehension, where the clause $\trm{sees}~ A_{sub}~ F$ ensures we only include facts visible to the submitting party. The $\trm{sees}$ predicate was defined back in \S\ref{s:Transactions}.

Importantly, we bind the \emph{fact} value instead of the whole \emph{factoid} to avoid confusion about what weight a pattern match should observe when a pattern before it consumes the same fact. Binding the whole factoid would allow rules to check the weights of factoids more directly than using @consume@ clauses, but interleaving consumption with matching would mean patterns could not be reordered freely. Similar issues arise in related \emph{active database systems}~\cite{Paton1999:Active}. A programmer would ultimately want to specify further behavior, but we leave this to future work.

Rules EvAny/First specify how a single fact should be selected from the set of gathered facts. With EvAny any fact can be selected. In EvFirst we compute a set of pairs $D^m$ of sort keys and values, and select the value with the smallest key. Handling @last@ is similar.

Rule EvConsumeSome evaluates the term specifying the fact weight to be consumed, and checks the current rule is in the use set of the fact. The EvConsumeNone version does not need the check, as the fact itself is not consumed. Rules EvGainNone/Some are similar, with EvGainSome checking that the fact supply the desired authority before returning it.

A direct implementation of the semantic pattern matching rules would essentially compute a relational join using naive cartesian product and filtering. A production implementation could instead use the RETE algorithm~\cite{Forgy1981:RETE, Doorenbos1995:ProductionMatching}, a parallel extension of it~\cite{Aref1998:LanaMatch}, or by conversion onto relational algebra for execution on a back-end relational database that maintains indexing structures.

Rule EvSay evaluates its arguments and produces the corresponding factoid. The remaining execution rules for the STLC term language are standard and have been omitted to save space.

\input{figure/Dynamic.tex}


% -----------------------------------------------------------------------------
\eject{}
\subsection{Properties}

We have formalised Rainfall in the Isabelle interactive theorem prover, and proved several isolation and authorisation properties of the dynamic semantics.
The following theorem states that execution of a rule can only depend on the facts explicitly used by the rule:

% \AMOS{These lemmas are boring, I think. The second is used in the proof of frame constriction.}
% \begin{lemma}
% New facts are included in the new store (trivial):
% $$
% \jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
% \implies
% D_{new}^m \subseteq S'
% $$
% \end{lemma}
% (Using the $\subseteq$ notation to refer to the multiset subset operation here -- would it be better to unroll it as something like $\forall (x,w) \in D_{new}^m.\ (x,w') \in S' \wedge w \le w'$ ?)
%
% \begin{lemma}
% Rules only spend and read values from the store:
% $$
% \begin{array}{c}
% \jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
% \implies \\
% F_{read}^r ~\Cup~ D_{spent}^n \subseteq S
% \end{array}
% $$
% \end{lemma}

\begin{theorem}
Frame constriction:
$$
\begin{array}{c}
\jFire{A}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\quad \jFire{A}{F_{read}^r \Cup D_{spent}^n}{R}{F_{read}^r}{D_{spent}^n}{D'}{S'} \quad
\\[1ex]
\multicolumn{1}{l}{ \texttt{where } D' ~=~ D_{new}^m \uplus (F_{read}^r - D_{spent}^n)}
\\
\end{array}
$$
\end{theorem}

This theorem has the hypothesis that the rule $R$ executes in store $S$, reading the facts $F_{read}^r$ and spending the facts $D_{spent}^n$, and resulting in the new facts $D_{new}^m$.
Executing the same rule in a restricted environment that contains only the read and spent facts will create the same new facts.
For the restricted environment, we use the $\Cup$ operator to union with the maximum weight of each fact, as facts that exist in both the read set and spent multiset should not be counted twice.
In the original execution, the updated store $S'$ contains the original store without the spent facts and with the new facts; in the restricted environment, the new store $D'$ contains the new facts as well as the unspent read facts.


The following two theorems state that execution can only depend upon facts visible to the submitter:

\begin{theorem}
Spend and read only visible:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\forall f \in F_{read}^r \Cup D_{spent}^n.\ \trm{sees}~ A_{sub}~ f
\end{array}
$$
\end{theorem}

\begin{theorem}
Store weakening with invisible facts: adding facts that are not visible to the submitter does not affect execution:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\forall f \in S_{others}.\ \neg (\trm{sees}~ A_{sub}~ f)
\implies \\
\jFire{A_{sub}}{S \uplus S_{others}}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}

The following theorem states that all authority used to create new facts must be gained from the matched facts.
The submitter's authority only affects which facts are visible, but the submitter's authority is not necessarily added to created facts:

\begin{theorem}
Authority comes from facts:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\forall f \in D_{new}^m.\ \forall a \in \trm{auth-by}~f.\ \exists d \in F_{read}^r \Cup D_{spent}^n.\ a \in \trm{auth-by}~d
\end{array}
$$
\end{theorem}

The following two theorems state that, for rules containing only `any' selectors, new facts and authorities can be added without changing the execution.
For programs containing `first' selectors, adding new facts, or making new facts visible, could change the minimum value selected by `first'.

\begin{theorem}
Store weakening for `any' selectors:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\trm{rule-contains-only-any}~R \implies \\
\jFire{A_{sub}}{S \uplus S_{others}}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}

\begin{theorem}
More permissions for `any' selectors:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\trm{rule-contains-only-any}~R \implies \\
\jFire{A_{sub} \cup A_{others}}{S}{R}{F_{read}^r}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}

\eject

