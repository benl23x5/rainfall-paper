
\clearpage{}
% -----------------------------------------------------------------------------
\section{Semantics}
The Rainfall semantics is specified in terms of a core language where pattern matching is desugared into set comprehension like generators, and we use a version of Simply Typed Lambda Calculus (STLC) for the rule bodies. We STLC for expositional purposes, though in a production implementation it may be preferable to define rule bodies using a more expressive term language such as a version System-F, or as a well defined bytecode. The key ideas of our system are embodied in the overall rule structure and authority mechanism, and are not specific to the language used for rule bodies.

% -----------------------------------------------------------------------------
\subsection{Grammar}
The grammar for the core language is in Figure~\ref{f:Grammar}, with a matching version of the coin transfer rule from Figure~\ref{f:CoinTransfer} given in Figure~\ref{f:CoinTransferDesugared}.
$Rule$ has a name, list of matching clauses and a term for the body that produces a set of new factoids. We use EBNF, so $Match+$ in the production for $Rule$ means there must be at least one match clause. Fact matching is desugared into a sequence of clauses of the form:
$$
X~ @from@~ N~ @where@~ M~ @select@~ Select~ @consume@~ M'~ @gain@~ M''
$$
This clauses states that we should scan through all facts in the store with name $N$, binding each in turn to the variable $X$ which is in scope for the sub-terms in the clause. We then \emph{gather} all such facts that satisfy predicate $M$ into a set, \emph{select} a single fact according to the $Select$ specifier, \emph{consume} the weight specified by $M'$ from the store, and \emph{gain} the authority specified by $M''$. In the $Select$ clause, @any@ indicates that any gathered that satisfies the @where@ predicate in the matching clause can be selected. For $@first@~ M$ and $@last@~ M$ we sort the facts by the key value $M$ and take the first or last one.

The gather/select/consume/gain process is a regularized database query, reminiscent to the FLWOR blocks of XQuery~\cite{Boag2002:XQuery}. The pattern binders like @?i@ and @?a@ that were used in the source code of Figure~\ref{f:CoinTransfer} have been expressed with simple predicates in the desugared version in Figure~\ref{f:CoinTransferDesugared}. We default the preciously elided @select@ and @consume@ clauses to @select any@ and @consume 1@ respectively.

The basis for the $Type$ and $Term$ grammars is STLC with records. Our only non-standard extension is the @say@ form which constructs a new fact value, much like a data constructor. We also include a few primitive operators to split out the components of a fact value, taking the @fact'payload@ and so on. In Figure~\ref{f:CoinTransferDesugared} we have also used some additional primitive operators for equality, boolean logic, and retained the sugared set literals. We also leave applications of the @fact'payload@ primitive implicit when retrieving fields from fact values. If @f@ is a fact whose payload has type $\tau$, and $\tau$ is a record type that includes a field with label @x@, then we just write @f.x@ instead of @(fact'payload@$_\tau$ @f).x@

\TODO{describe Fact and FACT types}


% -----------------------------------------------------------------------------
\begin{figure}
\begin{tabbing}
Mx \= MMMMx \= Mx \= MMM \= MMMM \kill
\\ $N,$ \> $Name$       \> ::= \> ...
\\ $L,$ \> $Label$      \> ::= \> ...
\\ $X,$ \> $Var$        \> ::= \> ...

\\[1ex]
  $R,$ \> $Rule$       \> ::= \> $\krule~ Name~ \kawait~ Match+~ \kto~ Term$
\\[0.5ex]
  $H,$ \> $Match$      \> ::= \> $Var~ \kfrom~ Name~ \kwhere~ Term$
\\      \>              \>     \> \hspace{1.6em} $\kselect~ Select~ \kconsume~ Term~ \kgain~ Term$
\\[0.5ex]
  $S,$ \> $Select$     \> ::= \> $\kany~ |~ \kfirst~ Term~ ~|~ \klast~ Term$

\\[1ex]
   $T,$ \> $Type$    \> ::= \> $\kUnit~ |~ \kBool~ |~ \kNat~ |~ \kText~ |~ \kSymbol~ |~ \kParty$
\\ \>                   \> ~|  \> $Type \to Type~ |~ \kSet~ Type~ |~ \kFact~ Type~ |~ \kFACT$

\\[1ex]
  $M,$   \> $Term$      \> ::= \> $Literal~ |~ Var~ |~ Term~ Term~ |~ \lambda Var : Type.~ Term$
\\ \>                   \> ~|  \> $[ (Label = Term)* ]~ |~ Term~ .~ Label$
\\[0.5ex] \>            \> ~|  \> $\ksay~ Name~ Term~$
\\        \>            \>     \> \hspace{0.5em} $\kby~ Term~ \kobs~ Term~ \kuse~ Term~ \knum~ Term$

\\[1ex]
  $V,$   \> $Value$     \> ::= \> $Literal~ |~ \lambda Var : Type.~ Term$
\\        \>            \> ~|  \> $[ (Label = Value)* ]$

\\[1ex]
 \> $Literal$           \> ::= \> $\kunit$ ~|~ $Bool$ ~|~ $Nat$ ~|~ $Text$ ~|~ $Symbol$ ~|~ $Party$
\end{tabbing}

\medskip
\begin{flushleft}
(primitive operators)
\end{flushleft}
\begin{tabbing}
MMMMMMMM \= Mx \= MMMMM \kill
   @fact'payload@$_T$ \> $:: @Fact@~ T \to T$
\\ @fact'by@$_T$      \> $:: @Fact@~ T \to \kSet~ \kParty$
\\ @fact'obs@$_T$     \> $:: @Fact@~ T \to \kSet~ \kParty$
\\ @fact'use@$_T$     \> $:: @Fact@~ T \to \kSet~ \kSymbol$
\\ @fact'num@$_T$     \> $:: @Fact@~ T \to \kNat$
\end{tabbing}

\medskip
\begin{flushleft}
(syntactic sugar)
\end{flushleft}
$$
\begin{array}{cc}
   \kretain \stackrel{\triangle}{=} \kconsume~ 0
\quad & \quad
   \ksame   \stackrel{\triangle}{=} \kgain~ \emptyset
\end{array}
$$

\medskip
\begin{flushleft}
(environments)
\begin{tabbing}
Mx              \= MMMMMx       \= Mx \= MMMMMMM \kill
   $\Gamma,$       \> $Env$     \> ::= \> $\cdot ~|~ Env,~ Var : Type$
\\ $\Sigma,$       \> $Decls$   \> ::= \> $\cdot ~|~ Decls,~ Name : [(Label : Type)*]$
\end{tabbing}
\end{flushleft}

\caption{Core Language Grammar}
\label{f:Grammar}
\end{figure}



% -----------------------------------------------------------------------------
\begin{figure}
\begin{small}
\begin{alltt}
rule  Transfer
await accept from Accept
       where true
       select any  consume 1  gain accept.accepter
 and  offer  from Offer
       where accept.id       == offer.id  &&
             accept.accepter == offer.receiver
       select any  consume 1  gain offer.giver
 and  coin   from Coin
       where coin.holder == offer.giver
       select any  consume 1  gain coin.issuer
to
    \{ say Coin [ stamp  = coin.stamp
               , holder = offer.receiver]
       by  \{ !Bank, offer.receiver \}  obs \{ \}
       use \{ 'Transfer \}              num 1) \}
\end{alltt}
\end{small}

\caption{Desugared Coin Transfer Rule}
\label{f:CoinTransferDesugared}
\end{figure}



% -----------------------------------------------------------------------------
\clearpage{}
\input{figure/Static.tex}

\subsection{Static Semantics}
The static semantics is shown in Figure~\ref{f:Statics}. Most judgment forms used two environments: $Decls$ ($\Sigma$) which maps fact names to their payload types, and $Env$ ($\Gamma$) which maps variable names to their types. The grammar for the environments is given back in Figure~\ref{f:Grammar}. In the source language example in Figure~\ref{f:CoinTransfer} we specified the payload type of each fact using the @fact@ keyword, though in the static semantics here we assume all such types are added to the @Decls@ environment before checking each rule.

The judgment ($\jOk{\Sigma}{R}$) checks that rule $R$ is well typed. In the premises we check the sequence of pattern matches, producing a type environment $\Gamma$, that specifies the types of variables that are in scope in the body of the rule. The body $M$ produces a set of weighted facts that are to be added to the store. The judgment $(\jTypeMatch{\Sigma}{\Gamma}{H^n}{\Gamma'})$ checks the sequence of pattern matches $H^n$, the following judgment form a single pattern match. The judgment ($\jTypeMatch{\Sigma}{\Gamma}{X ~;~ N ~;~ M}{\Gamma'}$) is used to check the \emph{gather} part of the pattern match, where $X$ is bound to to each fact of name $N$ in turn, and we keep the facts that match the boolean predicate $M$. The premise $(N:T) \in \Sigma$ retrieves the payload type $T$ of the fact, which is used to construct the type of $X$ which is in scope in the rule body $M$. Checking of $Select$ constructs and body terms is straightforward. The @say@ construct produces a value of the opaque @FACT@ type so that facts with different payload types can be collected into the same set.


% -----------------------------------------------------------------------------
\subsection{Dynamic Semantics}
The operational semantics essentially expresses relational joins using naive cartesian product and filtering, and has no indexing mechanism. A production implementation would implement the same semantics using the RETE algorithm~\cite{Forgy1981:RETE, Doorenbos1995:ProductionMatching}, a parallel extension of it~\cite{Aref1998:LanaMatch}, or by conversion onto relational algebra.

\input{figure/Dynamic.tex}

% -----------------------------------------------------------------------------
\subsection{Properties}

\AMOS{The following lemmas have been proved for a subset of the semantics without `retain' semantics}

\begin{lemma}
New facts are included in the new store (trivial):
$$
\jFire{A_{sub}}{S}{R}{D_{spent}^n}{D_{new}^m}{S'}
\implies
D_{new}^m \subseteq S'
$$
\end{lemma}
(Using the $\subseteq$ notation to refer to the multiset subset operation here -- would it be better to unroll it as something like $\forall (x,w) \in D_{new}^m.\ (x,w') \in S' \wedge w \le w'$ ?)

\begin{lemma}
Rules only spend what is in the store (pretty trivial):
$$
\jFire{A_{sub}}{S}{R}{D_{spent}^n}{D_{new}^m}{S'}
\implies
D_{spent}^n \subseteq S
$$
\end{lemma}

\begin{theorem}
Frame constriction: if a rule succeeds, the rule would succeed, resulting in the same value, in a store containing only what it spent:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\jFire{A_{sub}}{D_{spent}^n}{R}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}
This theorem statement isn't quite correct at the moment, because it's ignoring retained/non-consumed values. I will update this rule to find the non-consumed values in the spent facts and copy them from the original store after I have updated the formalisation. I think updating the formalisation will expose some other lemmas.

\begin{theorem}
Spend only visible: execution can only spend facts visible to the submitter:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\forall f \in D_{spent}^n.\ \trm{sees}~ A_{sub}~ f
\end{array}
$$
\end{theorem}

\begin{theorem}
Store weakening with invisible facts: adding facts that are not visible to the submitter does not affect execution:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\forall f \in S_{others}.\ \neg (\trm{sees}~ A_{sub}~ f)
\implies \\
\jFire{A_{sub}}{S \uplus S_{others}}{R}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}

\begin{theorem}
All authority in new facts is gained from spent facts:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\forall f \in D_{new}^m.\ \forall a \in \trm{auth-by}~f.\ \exists d \in D_{spent}^n.\ a \in \trm{auth-by}~d
\end{array}
$$
\end{theorem}

\AMOS{I haven't proved the following yet.}
The following theorems do not hold for all programs, but do hold for subsets.

\begin{theorem}
Store weakening for `any' selectors: if the rule doesn't contain any `first' selectors, we can add new facts without changing the execution:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\trm{rule-contains-only-any}~R \implies \\
\jFire{A_{sub}}{S \uplus S_{others}}{R}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}

This theorem doesn't hold for `first' selectors because adding new values to the store might change the minimum, and so change which value the first selector chooses.

\begin{theorem}
More permissions do not change behaviour of `any' selectors: if the rule doesn't contain any `first' selectors, we can add new authority without changing the execution:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\trm{rule-contains-only-any}~R \implies \\
\jFire{A_{sub} \cup A_{others}}{S}{R}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}

