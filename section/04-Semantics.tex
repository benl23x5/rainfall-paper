
\clearpage{}
\section{Semantics}
The key aspects of our system are captured in the rule structure and authority mechanism. For expositional purposes the term language has been specified as a version of simply typed lambda calculus. For a concrete implementation it may be preferrable to define rule bodies in terms of a well defined bytecode such as Web Assembly. \TODO{Cite Corda uses a determinised JVM to specify its contracts}

\AMOS{
In the execution stage, why is @say@ a side-effect that updates the facts list (EvSay), rather than just having the rule term evaluate to a list of factoids?
I think in a coloured petri net the transition function is a pure function from input values to output values, so I'd expect here a pure function from matched input factoids to output factoids.
}

% ---------------------------------------------------------
\begin{figure}
\begin{tabbing}
Mx \= MMMMx \= Mx \= MMM \= MMMM \kill
\\ $N,$ \> $Name$       \> ::= \> ...
\\ $L,$ \> $Label$      \> ::= \> ...
\\ $X,$ \> $Var$        \> ::= \> ...

\\[1ex]
        \> $Rule$       \> ::= \> $\krule~ Name~ \kawait~ Match+~ \kto~ Term$
\\ $H,$ \> $Match$      \> ::= \> $Var~ \kfrom~ Gather~ Select~ Consume~ Gain$
\\ $G,$ \> $Gather$     \> ::= \> $\kwhen~ Name~ Term+$
\\ $T,$ \> $Select$     \> ::= \> $\kany~ |~ \kfirst~ Term~ ~|~ \klast~ Term$
\\ $C,$ \> $Consume$    \> ::= \> $\kconsume~ Term$
\\ $I,$ \> $Gain$       \> ::= \> $\kgain~ Term$

\\[1ex]
   $\tau,$ \> $Type$    \> ::= \> $\kUnit~ |~ \kBool~ |~ \kNat~ |~ \kText~ |~ \kSymbol~ |~ \kParty$
\\ \>                   \> ~|  \> $\kSet~ Type~ |~ Type \to Type$

\\[1ex]
  $M,$   \> $Term$      \> ::= \> $Literal~ |~ Var~ |~ Term~ Term~ |~ \lambda Var : Type.~ Term$
\\ \>                   \> ~|  \> $[ (Label = Term)* ]~ |~ Term~ .~ Label$
\\[0.5ex] \>            \> ~|  \> $\ksay~ Name~ [~ (Label~ =~ Term)*~ ]~$
\\        \>            \>     \> \hspace{0.5em} $\kby~ Term~ \kobs~ Term~ \kuse~ Term~ \knum~ Term$

\\[1ex]
  $V,$   \> $Value$     \> ::= \> $Literal~ |~ \lambda Var : Type.~ Term$
\\        \>            \> ~|  \> $[ (Label = Value)* ]$

\\[1ex]
 \> $Literal$           \> ::= \> $\kunit$ ~|~ $Bool$ ~|~ $Nat$ ~|~ $Text$ ~|~ $Symbol$ ~|~ $Party$
\end{tabbing}

\medskip
\begin{flushleft}
(primitive operators)
\end{flushleft}
\begin{tabbing}
MMMMMMMM \= Mx \= MMMMM \kill
   @fact'payload@$_\tau$ \> $:: @Fact@~ \tau \to \tau$
\\ @fact'by@$_\tau$     \> $:: @Fact@~ \tau \to \kSet~ \kParty$
\\ @fact'obs@$_\tau$    \> $:: @Fact@~ \tau \to \kSet~ \kParty$
\\ @fact'use@$_\tau$    \> $:: @Fact@~ \tau \to \kSet~ \kSymbol$
\\ @fact'num@$_\tau$    \> $:: @Fact@~ \tau \to \kNat$
\end{tabbing}

\medskip
\begin{flushleft}
(syntactic sugar)
\end{flushleft}
$$
\begin{array}{cc}
   \kretain \stackrel{\triangle}{=} \kconsume~ 0
\quad & \quad
   \ksame   \stackrel{\triangle}{=} \kgain~ \emptyset
\end{array}
$$

\medskip
\begin{flushleft}
(environments)
\begin{tabbing}
Mx              \= MMMMMx       \= Mx \= MMMMMMM \kill
   $\Gamma,$       \> $TypeEnv$    \> ::= \> $\cdot ~|~ TypeEnv,~ Var : Type$
\\ $\Sigma,$       \> $Decls$      \> ::= \> $\cdot ~|~ Decls,~ Var : [(Label : Type)*]$
\end{tabbing}
\end{flushleft}


\caption{Core Language Grammar}
\end{figure}

\input{figure/Static.tex}

\input{figure/Dynamic.tex}



\begin{figure}
\begin{small}
\begin{alltt}
fact  Coin   [stamp: Symbol, holder: Party]
fact  Offer  [id: Symbol, giver: Party, receiver: Party]
fact  Accept [id: Symbol, accepter: Party]

node  Bank

rule  transfer
await Accept  as accept
 and  Offer   as offer
      where   accept.id       == offer.id,
              accept.accepter == offer.receiver
 and  Coin    as coin
      where   coin.holder     == offer.giver
to
      say Coin [ stamp  = coin.stamp
               , holder = offer.receiver]
      by  [auth| Bank, offer.receiver]
      use (elem offer.receiver)

scenario Bank, Alice, Bob
to do say Coin   [ stamp = 'Coin1001, holder = Alice]
      by  [auth| Bank, Alice]
      use (elem Alice)

      say Offer  [ id    = '1234
                 , giver = Alice, receiver = Bob]
      by  Alice use (elem Bob)

      say Accept [ id = '1234,    accepter = Bob]
      by  Bob   use (const true)
\end{alltt}
\end{small}

\caption{Coin Transfer Workflow}
\label{f:CoinTransferDesugared}
\end{figure}

\subsection{Lemmas}

\begin{lemma}
New facts are included in the new store (trivial):
$$
\jFire{A_{sub}}{S}{R}{D_{spent}^n}{D_{new}^m}{S'}
\implies
D_{new}^m \subseteq S'
$$
\end{lemma}
(Using the $\subseteq$ notation to refer to the multiset subset operation here -- would it be better to unroll it as something like $\forall (x,w) \in D_{new}^m.\ (x,w') \in S' \wedge w \le w'$ ?)

\begin{lemma}
Rules only spend what is in the store (pretty trivial):
$$
\jFire{A_{sub}}{S}{R}{D_{spent}^n}{D_{new}^m}{S'}
\implies
D_{spent}^n \subseteq S
$$
\end{lemma}

\begin{theorem}
Frame constriction: if a rule succeeds, the rule would succeed, resulting in the same value, in a store containing only what it spent:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\jFire{A_{sub}}{D_{spent}^n}{R}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}
This theorem statement isn't quite correct at the moment, because it's ignoring retained/non-consumed values. I will update this rule to find the non-consumed values in the spent facts and copy them from the original store after I have updated the formalisation. I think updating the formalisation will expose some other lemmas.

\AMOS{will fill in other lemmas soon}


