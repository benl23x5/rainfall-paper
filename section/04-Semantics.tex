
\clearpage{}
\section{Semantics}
The Rainfall semantics is specified in terms of a core language, where the pattern matching of rules has been desugared into set comprehension like generators. This form is convenient to discuss the semantics of the language, but is not appropriate for direct implementation. The operational semantics essentially expresses relational joins using naive cartesian product and filtering, and has no indexing mechanism. A production implementation would implement the same semantics using the RETE algorithm~\cite{Forgy1981:RETE, Doorenbos1995:ProductionMatching}, some extension of it~\cite{Aref1998:LanaMatch}, or by conversion onto relational algebra. Also, the key ideas of our system are embodied in the overall rule structure and authority mechanism. For expositional purposes we have used a version of Simply Typef Lambda Calculus (STLC) for the rule bodies, but for a concrete implementation it may be preferrable to define the rule bodies in a more expressive core language, or well defined bytecode.


\subsection{Grammar}
The grammar for the core language is in Figure~\ref{f:Grammar}, with a matching version of the coin transfer rule from Figure~\ref{f:CoinTransfer} given in Figure~\ref{f:CoinTransferDesugared}. A $Rule$ has a name, list of matching clauses and a term for the body that produces a set of new factoids. The head of the rule is desugared into a sequence of matching clauses of the form:
$$
X~ @from@~ N~ @where@~ M~ @select@~ Select~ @consume@~ M'~ @gain@~ M''
$$
This clauses states that we should scan through all facts in the store with name $N$, binding each in turn to the variable $X$ which is in scope for the sub-terms in the clause. We then \emph{gather} all such facts that satisfy predicate $M$ into a set, \emph{select} a single fact according to the $Select$ specifier, \emph{consume} the weight specified by $M'$ from the store, and \emph{gain} the authority specified by $M''$. In the $Select$ clause, @any@ indicates that any gathered that satisfies the @where@ predicate in the matching clause can be selected. For $@first@~ M$ and $@last@~ M$ we sort the facts by the key value $M$ and take the first or last one.

The gather/select/consume/gain process is a regularized database query, reminiscent to the FLWOR blocks of XQuery~\cite{Boag2002:XQuery}. The pattern binders like @?i@ and @?a@ that were used in the source code of Figure~\ref{f:CoinTransfer} have been expressed with simple predicates in the desugared version in Figure~\ref{f:CoinTransferDesugared}. We default the preciously elided @select@ and @consume@ clauses to @select any@ and @consume 1@ respectively.

The basis for the $Type$ and $Term$ grammars is STLC with records. Our only non-standard extension is the @say@ form which constructs a new fact value, much like a data constructor. We also include a few primitive operators to split out the components of a fact value, taking the @fact'payload@ and so on. In Figure~\ref{f:CoinTransferDesugared} we have also used some additional primitive operators for equality, boolean logic, and retained the sugared set literals. We also leave applications of the @fact'payload@ primitive implicit when retrieving fields from fact values. If @f@ is a fact whose payload has type $\tau$, and $\tau$ is a record type that includes a field with label @x@, then we just write @f.x@ instead of @(fact'payload@$_\tau$ @f).x@



% -----------------------------------------------------------------------------
\begin{figure}
\begin{tabbing}
Mx \= MMMMx \= Mx \= MMM \= MMMM \kill
\\ $N,$ \> $Name$       \> ::= \> ...
\\ $L,$ \> $Label$      \> ::= \> ...
\\ $X,$ \> $Var$        \> ::= \> ...

\\[1ex]
        \> $Rule$       \> ::= \> $\krule~ Name~ \kawait~ Match+~ \kto~ Term$
\\[0.5ex]
  $H,$ \> $Match$      \> ::= \> $Var~ \kfrom~ Name~ \kwhere~ Term$
\\      \>              \>     \> \hspace{1.6em} $\kselect~ Select~ \kconsume~ Term~ \kgain~ Term$
\\[0.5ex]
  $T,$ \> $Select$     \> ::= \> $\kany~ |~ \kfirst~ Term~ ~|~ \klast~ Term$

\\[1ex]
   $\tau,$ \> $Type$    \> ::= \> $\kUnit~ |~ \kBool~ |~ \kNat~ |~ \kText~ |~ \kSymbol~ |~ \kParty$
\\ \>                   \> ~|  \> $\kSet~ Type~ |~ Type \to Type$

\\[1ex]
  $M,$   \> $Term$      \> ::= \> $Literal~ |~ Var~ |~ Term~ Term~ |~ \lambda Var : Type.~ Term$
\\ \>                   \> ~|  \> $[ (Label = Term)* ]~ |~ Term~ .~ Label$
\\[0.5ex] \>            \> ~|  \> $\ksay~ Name~ Term~$
\\        \>            \>     \> \hspace{0.5em} $\kby~ Term~ \kobs~ Term~ \kuse~ Term~ \knum~ Term$

\\[1ex]
  $V,$   \> $Value$     \> ::= \> $Literal~ |~ \lambda Var : Type.~ Term$
\\        \>            \> ~|  \> $[ (Label = Value)* ]$

\\[1ex]
 \> $Literal$           \> ::= \> $\kunit$ ~|~ $Bool$ ~|~ $Nat$ ~|~ $Text$ ~|~ $Symbol$ ~|~ $Party$
\end{tabbing}

\medskip
\begin{flushleft}
(primitive operators)
\end{flushleft}
\begin{tabbing}
MMMMMMMM \= Mx \= MMMMM \kill
   @fact'payload@$_\tau$ \> $:: @Fact@~ \tau \to \tau$
\\ @fact'by@$_\tau$      \> $:: @Fact@~ \tau \to \kSet~ \kParty$
\\ @fact'obs@$_\tau$     \> $:: @Fact@~ \tau \to \kSet~ \kParty$
\\ @fact'use@$_\tau$     \> $:: @Fact@~ \tau \to \kSet~ \kSymbol$
\\ @fact'num@$_\tau$     \> $:: @Fact@~ \tau \to \kNat$
\end{tabbing}

\medskip
\begin{flushleft}
(syntactic sugar)
\end{flushleft}
$$
\begin{array}{cc}
   \kretain \stackrel{\triangle}{=} \kconsume~ 0
\quad & \quad
   \ksame   \stackrel{\triangle}{=} \kgain~ \emptyset
\end{array}
$$

\medskip
\begin{flushleft}
(environments)
\begin{tabbing}
Mx              \= MMMMMx       \= Mx \= MMMMMMM \kill
   $\Gamma,$       \> $TypeEnv$    \> ::= \> $\cdot ~|~ TypeEnv,~ Var : Type$
\\ $\Sigma,$       \> $Decls$      \> ::= \> $\cdot ~|~ Decls,~ Name : [(Label : Type)*]$
\end{tabbing}
\end{flushleft}

\caption{Core Language Grammar}
\label{f:Grammar}
\end{figure}



% -----------------------------------------------------------------------------
\begin{figure}
\begin{small}
\begin{alltt}
rule  Transfer
await accept from Accept
       where true
       select any  consume 1  gain accept.accepter
 and  offer  from Offer
       where accept.id       == offer.id  &&
             accept.accepter == offer.receiver
       select any  consume 1  gain offer.giver
 and  coin   from Coin
       where coin.holder == offer.giver
       select any  consume 1  gain coin.issuer
to
    \{ say Coin [ stamp  = coin.stamp
               , holder = offer.receiver]
       by  \{ !Bank, offer.receiver \}  obs \{ \}
       use \{ 'Transfer \}              num 1) \}
\end{alltt}
\end{small}

\caption{Desugared Coin Transfer Rule}
\label{f:CoinTransferDesugared}
\end{figure}



% -----------------------------------------------------------------------------
\clearpage{}
\input{figure/Static.tex}
\subsection{Static Semantics}




\input{figure/Dynamic.tex}

% -----------------------------------------------------------------------------
\subsection{Properties}

\begin{lemma}
New facts are included in the new store (trivial):
$$
\jFire{A_{sub}}{S}{R}{D_{spent}^n}{D_{new}^m}{S'}
\implies
D_{new}^m \subseteq S'
$$
\end{lemma}
(Using the $\subseteq$ notation to refer to the multiset subset operation here -- would it be better to unroll it as something like $\forall (x,w) \in D_{new}^m.\ (x,w') \in S' \wedge w \le w'$ ?)

\begin{lemma}
Rules only spend what is in the store (pretty trivial):
$$
\jFire{A_{sub}}{S}{R}{D_{spent}^n}{D_{new}^m}{S'}
\implies
D_{spent}^n \subseteq S
$$
\end{lemma}

\begin{theorem}
Frame constriction: if a rule succeeds, the rule would succeed, resulting in the same value, in a store containing only what it spent:
$$
\begin{array}{c}
\jFire{A_{sub}}{S}{R}{D_{spent}^n}{D_{new}^m}{S'}
\implies \\
\jFire{A_{sub}}{D_{spent}^n}{R}{D_{spent}^n}{D_{new}^m}{S'}
\end{array}
$$
\end{theorem}
This theorem statement isn't quite correct at the moment, because it's ignoring retained/non-consumed values. I will update this rule to find the non-consumed values in the spent facts and copy them from the original store after I have updated the formalisation. I think updating the formalisation will expose some other lemmas.

\AMOS{will fill in other lemmas soon}


