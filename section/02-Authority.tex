
\clearpage{}


\begin{figure}
\begin{small}
\begin{alltt}
fact  Coin   [issuer: Party, holder: Party]
fact  Offer  [id: Symbol, giver: Party, receiver: Party]
fact  Accept [id: Symbol, accepter: Party]

rule  transfer
await Accept [id = ?i, accepter = ?a]  gain a
  and Offer  [id = i,  giver = ?g, receiver = ?a]
  and Coin   [issuer = ?s, holder = g] gain s
to
  say Coin   [issuer = s, holder = r]
   by \{s, r\} use \{transfer\}
\end{alltt}
\end{small}
\caption{Coin Transfer Workflow}
\label{f:CoinTransfer}
\end{figure}


% -------------------------------------------------------------------------------------------------
\section{Facts, Weights, Rules and Authority}
Rainfall has two main components, a ledger of facts and a set of rules. Parties using the system add facts to the ledger, cryptographically signing them using public key encryption, and thus embodying them with their authority. Rules match on collections of facts, and when successful, consume some of the facts, and create new facts. The new facts are embodied with a subset of the authority of the matched facts. Not all facts are visible to all parties, rather, the visibility of facts is managed using the authority metadata of each fact. We describe facts, rules and fact meta data in turn, finishing with the formal definition of the ledger data model.


% -----------------------------------------------------------------------------
\subsection{Facts}
\label{s:Facts}
Figure~\ref{f:CoinTransfer} contains the fact and rule definitions for a simple coin transfer workflow. A @fact@ declaration gives the \emph{tag} and \emph{payload} types of a particular sort of fact. In this example, a @Coin@ fact describes a single coin that has been created by an @issuer@ party and is currently held by a @holder@. An @Offer@ fact represents an offer by a coin holder, the @giver@, which offers to give their coin to a second party, the @receiver@. The offer also carries a value of abstract @Symbol@, type that is used to uniquely identify the offer. An @Accept@ fact represents that fact that the receiver of the offer does indeed wish to accept a coin offer with the given identifier.

As an example use, suppose we have facts of the above types currently on the ledger:
\begin{small}
\begin{code}
 Coin   [issuer = !Isabelle, holder = !Alice]
 Offer  [id = '1234, giver = !Alice, receiver = !Bob]
\end{code}
\end{small}

Names prefixed by @!@ are identifiers of parties (principles) using the system, and their values have type @Party@. Names prefixed by @'@ are symbols (strings), and their values have type @Symbol@. The facts reveal that @Alice@ wishes to transfer the coin she currently holds to @Bob@. If @Bob@ wishes to accept the transfer he can then add the following fact to the ledger:
\begin{small}
\begin{code}
 Accept [id = '1234, accepter = !Bob]
\end{code}
\end{small}

Given the @Coin@, @Offer@, and @Accept@ facts, the @transfer@ rule from Figure~\ref{f:CoinTransfer} can fire, which \emph{consumes} the three above facts and produces a new one:
\begin{small}
\begin{code}
 Coin [issuer = !Isabelle, holder = !Bob]
\end{code}
\end{small}

This new fact shows that the coin now belongs to Bob, or alternatively, the old coin has been destroyed and a new one created that is owned by Bob. In financial terms this workflow is known as a \emph{bilateral transfer} because the receiver must explicitly accept the offered coin, rather than being an \emph{unilateral transfer}, where the receiver has no say in whether the transfer takes place.


% -----------------------------------------------------------------------------
\subsection{Rules}
The @transfer@ rule of Figure~\ref{f:CoinTransfer} how the facts of the above types can be combined. The rule is written in a syntax similar to existing production rule systems based on OPS5. The rule definition has the form (@rule@ \emph{name} @await@ \emph{pattern} @to@ \emph{body}) where \emph{name} of the rule, \emph{pattern} specifies which facts must be matched for the rule to fire, and \emph{body} is a term that optionally adds new facts to the ledger.


Names prefixed by @?@ are binding occurrences of variables, so the rule waits for an @Accept@ fact with its @id@ field set to some value, binds it to @i@, and then waits for an @Offer@ fact whose @id@ field is set to the same value. The runtime intuition is that matching of facts proceeds in sequence, so the rule will wait for an @Accept@ fact, then an @Offer@ fact, then a @Coin@ fact. Variables bound in earlier facts are in scope when matching latter facts, and also in the body. Implementations of traditional production rule engines use the RETE~\cite{Forgy1981:RETE} algorithm, or some extension of it, to implement rule matching in an efficient way. We consider implementation in \REF.

By default, when a rule matches on a given fact, that fact is \emph{spent}, meaning that it is removed from the active ledger state. As we will see in \REF the knowledge that that fact once existed is not lost, as the implementation retains the full history of transactions, but after a fact is spent it can no longer be matched in a subsequent rule.


% -----------------------------------------------------------------------------
\subsection{Weights}
\label{s:Weights}
Suppose @Bob@ already had a coin, and then receives another one. We manage this situation by giving each fact its first piece of meta-data, a \emph{weight}, which a non-negative integer. We treat the weight as indicating the number of ``copies'' of the same fact on the ledger. When writing fact values we indicate the weight using @num@ keyword next to it, typically eliding it when it has value one.

For example, if the ledger already contained a weighted fact:
\begin{small}
\begin{code}
 Coin [issuer = !Isabelle, holder = !Bob] num 5
\end{code}
\end{small}
%
And then Alice transfers Bob a new coin, then the new entry on the ledger would become:
\begin{small}
\begin{code}
 Coin [issuer = !Isabelle, holder = !Bob] num 6
\end{code}
\end{small}
%


% -----------------------------------------------------------------------------
\subsection{Authority}
\label{s:Authority}
A given currency can only retain value when it is \emph{scarce}. Commodity currencies like gold and silver are scarce due to the physical difficulty of digging them up. Fiat currencies like Icelandic Kr\'ona (ISK) are scarce because a central authority, the Icelandic Government, only issues a limited amount per year. Crypto currencies like Bitcoin are scarce because they represent the solution of a particular cryptographic problem, which at a particular time, required significant energy to solve. Whether a currency \emph{has} ``value'' is a different question, but a currency needs to be scarce to retain it.

In our coin example, scarcity of coin facts is enforced by requiring that they are all issued by a single party @!Isabelle@. We assume that everyone using the system agrees that @!Isabelle@ is a trustworthy individual, and will not add new, signed @Coin@ facts to the ledger in an inappropriate way\footnote{meaning they will not print money, or at least, not too much}.

When new coin facts \emph{are} added, they are given the authority of both the issuer and the initial holder of the coin. In the example of \S\ref{s:Facts} the original coin was issued by @!Isabelle@ and held by @!Alice@, so the fact carries the authority of both. The set of parties of which a fact was authorized by is called the \emph{by-authority set}. During the operation of the ledger we allow any party to add any fact with its own authority at any time. Likewise, any party may remove a fact from the ledger at any time, provided the fact is authorized only with that parties authority. Ensuring that Coin facts are always authorized by two parties, the issuer and current holder, ensures that neither can unilaterally remove the coin fact from the system. Coins can only be consumed by the action of pre-agreed rules that first collect the authority of all relevant parties.


\eject
% -----------------------------------------------------------------------------
\subsection{Privacy}
When a fact carries the authority of a particular party then it is natural that the party should be aware of the fact. In Rainfall, all facts with the authority of a particular party are visible to that party. For example, the original @Coin@ fact from \S\ref{s:Facts} carries the authority of both @!Isabelle@ and @!Alice@, so those parties will be informed of the creation and subsequent consumption of that fact.

In practical commercial workflows, it is often the case that extra parties must be informed of events such as coin transfers and contract completion, even though they do not have direct authority over the facts themselves. For example, in Australia, the Australian Securities and Investments Commission (ASIC) monitors the activity of the Australian Securities eXchange (ASX), even though they are not themselves a giver or receiver on any of the currency transfers or securities transactions. In Rainfall, we use an additional meta-data field associated with each fact, called the \emph{obs-authority} set to collect the set of parties that can observe a fact but do not have authority over it. The obs-authority set of a fact may contain the name of a party that is also in the by-authority set for the same fact, though it provides no additional benefit. Privacy will be discussed in more detail in \S\ref{s:Privacy}


% -----------------------------------------------------------------------------
\subsection{Valid Rules}
To conserve the overall number of coin facts we must each rule that adds a coin fact also consumes an identical number of coin facts. As we allow the body of a rule to contain arbitrary code, deciding whether or not an arbitrary rule preserves the quantify of some fact is undecidable in general. Instead of trying to specify an (inevitably incomplete) automated analysis we instead require the parties using the system to ensure the rules use had the desired properties themselves. Each fact is then annotated with the cryptographic hash of the rules that are permitted to consume, and gain authority from it. This final piece of meta-data called the \emph{valid rules set}.

The valid rules set for a fact determines the business-level meaning of the fact. In our current example, the coin facts have the name of the single @transfer@ rule in their valid rules set, meaning that coins are things that can be transferred, but nothing else. As we mentioned in \S\ref{s:Authority} we also arrange coin facts to always be authorized by two separate parties, the issuer and the holder. This means that no single party can unilaterally create or remove coin facts, but they can come to an agreement that through the use of the system, the total number of coin facts that have this special form will be conserved.


% -----------------------------------------------------------------------------
\subsection{Now with Metadata}

Returning to our coin transfer example from \S\ref{s:Facts}, we restate the facts that will be consumed, along with all their meta data.

\begin{small}
\begin{code}
 Accept [id = '1234, accepter = !Bob]
    by  {!Bob}                obs {!Mona}
    use {'transfer}           num 1

 Offer  [id = '1234, giver = !Alice, receiver = !Bob]
    by  {!Alice}              obs {}
    use {'transfer}           num 1

 Coin   [issuer = !Isabelle, holder  = !Alice]
    by  {!Isabelle, !Alice}   obs {}
    use {'transfer}           num 1
\end{code}
\end{small}

In summary, the @Accept@ in the first fact is the \emph{tag} of the fact, and the following record the \emph{payload}. The @by@ field specifies the \emph{by-authority set}, which contains the parties that the fact has been authorized by. The @obs@ field specifies the \emph{obs-authority set}, which contains the extra parties that can observe the fact but do not necessarily authorize it. The @use@ field gives the \emph{rules set}, which are the names of the rules that consume a fact and gain authority from it. Finally, the @num@ field gives the \emph{weight} of the fact, which can be interpreted as the number of usable ``copies'' of the fact.

When the rule from Figure~\ref{f:CoinTransfer} matches on each of these facts in turn, it gains the authority specified by the @gain@ clause in the pattern match. For the above facts, the first pattern gains authority of @!Bob@, and the third the authority of @!Isabelle@ and @!Alice@. When all three patterns have matched the rule \emph{fires} and executes the body with all the matched variables from @?i@, @?a@, @?r@ and so on in scope. In this case the body uses the @say@ clause to produce a new fact, giving it the authority of the issuer @!Isabelle@ and new holder @!Bob@. Note that we do not need a @gain g@ clause in the second pattern, because if @Alice@ does not want to give away her coin then she can just not add an @Offer@ fact to the system. The @Offer@ fact can be consumed by virtue of the fact that it has @transfer@ in its valid rules set. The rules needs to gain the authority of @Isabelle@ and @Bob@ to create the new @Coin@ fact, but as no new fact is created with the authority of @Alice@, it does not need hers as well.

We are now in a position to describe the full data model of the ledger, which appears below. The current ledger state is a map from $Fact$ to its current $Weight$, where the $Fact$ includes the \emph{by-authority}, \emph{obs-authority} and \emph{rules-set} along with the tag and payload. If two facts have different authority meta-data then they are taken to be different facts.
$$
\begin{array}{ll}
\\ State   & = Map~ Fact~ Weight
\\ Fact    & = (Name, Record, By, Obs, Rules)
\\ Record  & = List~ (Name, Value)
\\ By      & = Set~ Party
\\ Obs     & = Set~ Party
\\ Rules   & = Set~ Name
\\[1ex]

\end{array}
$$
If a given fact does not appear in the set then we assume that the weight is zero. The $State$ here is the current state of the ledger. As we discussed in \REF the \emph{ledger} itself is modeled as a list of transactions, that includes the full history of all changes, whereas a $State$ refers to the facts that are active after the most recent transaction.

In this semantic model we specify the parties that authorize a given fact just by including their names in the appropriate set of the fact tuple. We discuss the concrete implementation details of cryptographic signing and hashing in \REF.


% -----------------------------------------------------------------------------
\subsection{Ledger Integrity}
As mentioned in the previous section, the new facts created by a rule can be authorized by a set of parties that is at most the parties whose authority has been gained by matching on existing facts. This restriction allows Rainfall to operate as an open system, where arbitrary new parties can join, and create whatever new facts and rules they see fit. In doing so, it is not possible for a new party to cause a fact to be created that is carries the authority of another party that did not explicitly agree to its creation. For example, consider the following rule:

\begin{small}
\begin{code}
  rule  mint
  await Mint [minter = ?m] gain m
   to   say Coin [issuer = 'Isabelle, holder = m]
         by {'Isabelle, m} use {transfer}
\end{code}
\end{small}

An arbitrary party can add a @Mint@ fact to the system to trigger this rule, and state that they should be the holder of the new coin. However, there is no way for the rule to gain the authority of @Isabelle@, the usual coin issuer. As we will see in \REF our operational semantics performs a runtime check to ensure that the authority of all new facts created by a rule are covered by the authority that has been gained by matching against existing ones.


