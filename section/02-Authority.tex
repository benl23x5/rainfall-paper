
\clearpage{}

\begin{figure}
\begin{small}
\begin{alltt}
fact  Coin   [issuer: Party,  holder:   Party]
fact  Offer  [id:     Symbol, terms:    Text,
              giver:  Party,  receiver: Party ]
fact  Accept [id:     Symbol, accepter: Party]

rule  transfer
await Accept [id = ?i, accepter = ?a]            gain \{a\}
  and Offer  [id = i,  giver = ?g, receiver = a] gain \{g\}
  and Coin   [issuer = !Isabelle,  holder = g]
      gain \{!Isabelle,g\}
to
  say Coin   [issuer = !Isabelle,  holder = a]
   by \{!Isabelle,a\}  use \{'transfer\}
\end{alltt}
\end{small}
\caption{Coin Transfer Workflow}
\label{f:CoinTransfer}
\end{figure}


% -------------------------------------------------------------------------------------------------
\section{Facts, Rules, and Authority}
\label{s:FactsWeights}
The Rainfall programming model includes a ledger of facts and a set of rules. Parties using the system add facts to the ledger, cryptographically signing them to demonstrate that they authorize their contents. Rules match on several facts and create new facts, possibly consuming matched facts in the process. Rules can also gain authority from matched facts, and new facts created can be given a subset of the authority gained from the matched facts. The set of facts visible to each party is also specified by the authority system, so not all facts need to be visible to all parties. In this section we describe facts, rules and the authority system, finishing with the formal definition of the data model.


% -----------------------------------------------------------------------------
\subsection{Facts}
\label{s:Facts}
Figure~\ref{f:CoinTransfer} contains the fact and rule definitions for a simple coin transfer workflow. A @fact@ declaration gives the \emph{tag} and \emph{payload} types of each sort of fact used in the workflow. In this example, a @Coin@ fact represents a single coin that has been created by an @issuer@ party, and is currently held by a @holder@. An @Offer@ fact represents an offer by the coin holder, the @giver@, to transfer their coin to a @receiver@. The offer includes a value of abstract @Symbol@, type that uniquely identifies the offer, and a text string describing the terms of the offer. An @Accept@ fact specifies that the receiver does indeed wish to accept a coin offer with the given terms.

For example, we suppose we have the following facts:
\begin{small}
\begin{code}
 Coin   [issuer = !Isabelle, holder = !Alice]
 Offer  [id     = '1234,  terms    = "To purchase a guitar"
         giver  = !Alice, receiver = !Bob]
\end{code}
\end{small}

Names prefixed by @!@ are literal identifiers of the parties using the system, and their values have type @Party@. Names prefixed by @'@ are symbolic identifiers (strings), and their values have type @Symbol@. The facts reveal that @Alice@ wishes to transfer her coin to @Bob@ for the purchase of a guitar. If @Bob@ wishes to accept her offer he can add the following fact to the ledger:
\begin{small}
\begin{code}
 Accept [id = '1234, accepter = !Bob]
\end{code}
\end{small}

Given the @Coin@, @Offer@, and @Accept@ facts, the @transfer@ rule from Figure~\ref{f:CoinTransfer} can fire, which \emph{consumes} the three input facts and produces a new one:
\begin{small}
\begin{code}
 Coin   [issuer = !Isabelle, holder = !Bob]
\end{code}
\end{small}

This new coin belongs to Bob, alternatively, we could say that the coin Alice had has been transferred to Bob.

% CUT: In financial terms, this workflow is a \emph{bilateral transfer} because the receiver must explicitly accept the offered coin, rather than being an \emph{unilateral transfer}, where the receiver has no say in whether the transfer takes place.


% -----------------------------------------------------------------------------
\subsection{Weights}
\label{s:Weights}
Suppose Bob already had a coin, and then receives another one. We handle this by giving each fact a \emph{weight}, which specifies an positive integral number of ``copies''. We indicate the weight of a fact using the @num@ keyword, typically eliding it the weight is one.

For example, suppose the ledger already contained:
\begin{small}
\begin{code}
 Coin [issuer = !Isabelle, holder = !Bob]  num 5
\end{code}
\end{small}
%
When Alice transfers an additional coin to Bob the entry on the ledger would become:
\begin{small}
\begin{code}
 Coin [issuer = !Isabelle, holder = !Bob]  num 6
\end{code}
\end{small}
%
Rules can also consume an arbitrary weight of a fact, including zero which non-destructively reads it, which we discuss in \REF.

% TODO: discuss extension of using general monoids for weights, not just natural number and addition,
%       if we have this then we'd also need to put constraints on the weights, like >= 0.


% -----------------------------------------------------------------------------
\subsection{Rules}
The @transfer@ rule of Figure~\ref{f:CoinTransfer} specifies how existing facts can be combined to create new facts. The rule is written in a syntax based on production rule systems such as OPS5~\cite{Forgy1981:OPS5} and CLIPS~\cite{Riley2017:CLIPS}. The rule definition has the form (@rule@ \emph{name} @await@ \emph{pattern} @to@ \emph{body}) where \emph{pattern} specifies which facts must be matched for the rule to fire, and \emph{body} is a pure term expression that constructs the set of new facts to add to the ledger. These new facts can be authorized by a subset of the parties specified by the @gain@.

Names prefixed by @?@ are binding occurrences of variables, so the rule requires an @Accept@ fact with its @id@ field set to some value, binds it to @i@, and must wait for an @Offer@ fact whose @id@ field is set to the same value. The runtime intuition is that matching of facts proceeds in sequence, so the rule will wait for an @Accept@ fact, then an @Offer@ fact, then a @Coin@ fact. Variables bound in earlier facts are in scope when matching latter facts, and also in the body. Implementations of traditional production rule engines based on the RETE~\cite{Forgy1981:RETE} algorithm do not require facts to be matched in order, but we fix the sequence here to simplify the operational semantics.

By default, when a rule matches its required facts those facts are consumed from the active ledger state, and any new facts created in an atomic transaction. We also refer to the process of consuming a fact as \emph{spending} that fact, after the original Unspent Transaction Output (UTxO)~\cite{Zahnentferner2018:UTxO} model of the Bitcoin system.

% CUT: When a fact is spent we say it has become \emph{inactive}, and can no longer be matched by a subsequent rule.


% -----------------------------------------------------------------------------
\subsection{Authority}
\label{s:FactAuthority}
A given currency can only retain value when it is \emph{scarce}. Commodity currencies like gold and silver are scarce due to the physical difficulty of digging them out of the ground. Fiat currencies like Icelandic Kr\'ona (ISK) are scarce because a central authority issues a limited number per year. Bitcoins are scarce because they represent the solution of a particular cryptographic problem, which at a particular time, required significant energy to solve.

In our coin example, the scarcity of coin facts is enforced by requiring that they are authorized by an issuing party @!Isabelle@. We assume that everyone using the system trusts @!Isabelle@ to not add new, signed @Coin@ facts to the ledger in an inappropriate way.\footnote{meaning they will not print money, or at least, not too much} In a private financial system @!Isabelle@ might represent a bank. In a public ledger system, a fixed supply of coins might be generated using a secure multiparty protocol to sign the facts similarly to how the ZCash system~\cite{Bowe2018:MultiParty, Hopwood2016:zcash} was initialized.

In our current example, when coin facts are created we assume they are authorized by both the issuer and the initial holder of the coins. The set of parties which authorize a fact is called the \emph{by-authority} set. Any party can add any fact to the ledger at any time, provided the fact is only given that parties authority. Likewise, any party can consume (spend) a fact from the ledger at any time, provided the fact was only authorized by that parties authority. Ensuring that coin facts are always authorized by two parties ensures that neither can unilaterally create, transfer or consume them. Shared facts can only be modified by pre-agreed rules that first collect the authority of all relevant parties. Our by-authority sets are similar to the sets of \emph{contract signatories} in DAML~\cite{DA2019:DAML}.

In our data model we attach the by-authority set directly to the fact data, so rule code can read the set of parties that have authorized that fact just as they would read the payload data. In a concrete implementation, when a new fact is created directly by a party then it would be cryptographically signed by that party, demonstrating that the by-authority set containing their own name is as intended. When a new fact is created by a rule firing then the transaction log of the system, which lists the rule name along with the facts spent and created by that rule, records that the authorization of these new facts is as intended. We discuss transactions further in \S\ref{s:Transactions}.


% -----------------------------------------------------------------------------
\subsection{Observation}
\label{s:Observation}
When a fact has been authorized by a particular party then naturally that party should be able to see the details of that fact. In Rainfall, facts that are authorized by a party are visible to that party. For example, the original @Coin@ fact from \S\ref{s:Facts} is authorized by both Isabelle and Alice, so those parties will be informed of the creation and subsequent consumption of that fact. However, the @Offer@ fact that Alice creates is authorized by Alice alone, so we need an additional mechanism to reveal it to Bob. We attach an additional set, the \emph{obs-authority} set, to each fact, which lists the extra parties that are permitted to observe a fact but have not authorized its creation. The same party name may be in both the by-authority set, as well as the obs-authority set, though this provides no additional benefit. We also discuss this further \S\ref{s:NestedTransactions}.

% TODO: as an extension could make it so rule can only see the other parties that can observe a fact


% -----------------------------------------------------------------------------
\subsection{Usable Rules}
Rainfall is an open system, in the sense that new parties can join at any time, adding new facts and rules as they see fit. As mentioned in \S\ref{s:FactAuthority}, a party can unilaterally create and consume any fact in the system, provided it is authorized by that party alone. To also allow parties to  add any \emph{rule} they like, we must ensure that these new rules do not consume or gain authority from other parties in a way that those other parties did not intend. This is achieved by attaching a final set, the \emph{use-set}, to each fact, which lists the rules that can consume or gain authority from (can use) that fact.


In a concrete implementation we would record the cryptographic hash of the rule code, instead of just the literal rule name, but we use the name in our examples for readability. For practical workflows the set of rules that can consume a given fact could be quite large. We assume that the underlying implementation represents facts with the same use-set efficiently. This could be done by recording the hash of each \emph{set} of rule hashes along with individual facts, instead listing the per-rule hashes directly.

The valid rules set for a fact specifies the business-level meaning of the fact. For our transfer example, the consumed and created @Coin@ facts all have a use-set that specifies the single @transfer@ rule. Coins are things that can be transferred and nothing else. As we will see in \S\ref{s:Upgrade} attaching the use-set directly to facts make it easy to support the upgrade of facts formats and rule code, which is usually necessary in practical information systems.


% -----------------------------------------------------------------------------
\subsection{Data Model}
\label{s:NowWithMetadata}
\label{s:DataModel}
Returning to the coin transfer facts listed in \S\ref{s:Facts}, we now restate them with all their annotations, assuming that Alice starts out owning 100 coins.
\begin{small}
\begin{code}
 Coin   [issuer = !Isabelle, holder  = !Alice]
    by  {!Isabelle, !Alice}  obs {}
    use {'transfer}          num 100

 Offer  [id = '1234, terms = "To purchase a Guitar"
         giver = !Alice, receiver = !Bob]
    by  {!Alice}             obs {!Bob}
    use {'transfer}          num 1

 Accept [id = '1234, accepter = !Bob]
    by  {!Bob}               obs {!Alice}
    use {'transfer}          num 1
\end{code}
\end{small}
In summary, the word @Coin@ in the first fact is its \emph{tag}, and the following record the \emph{payload}. The @by@ keyword marks the \emph{by-authority} set, lists the parties that the fact has been authorized by. The @obs@ keyword marks the \emph{obs-authority} set, which lists extra the parties that can observe the fact but do not necessarily authorize it. The @use@ keyword marks the \emph{use}, which lists the names of the rules that can consume a fact or gain authority from it. Finally, the @num@ keyword marks the \emph{weight} of the fact, which can be interpreted as the number of active copies of the fact on the ledger.

The full data model is specified below. The current ledger state is a map from $Fact$ to its current $Weight$, where the $Fact$ includes the \emph{by-authority}, \emph{obs-authority} and \emph{use} set along with the tag and payload. If facts with differing authority or use set annotations are different facts.
$$
\begin{array}{ll}
   State   & = Map~ Fact~ Weight
\\ Fact    & = (Name, Record, By, Obs, Rules)
\\ Record  & = List~ (Name, Value)
\\ By      & = Set~ Party
\\ Obs     & = Set~ Party
\\ Rules   & = Set~ Name
\\ Weight  & = Nat
\end{array}
$$
When a the state has a fact with weight zero then we treat this as being identical to a state without that fact listed at all. We could equivalently specify the state as being a \emph{multiset} of facts, but in most cases we find treating it as a map from facts to their weights as being more intuitive. Note that the $State$ here is the current \emph{active state} of the ledger. In related work on distributed ledgers the \emph{ledger} itself is typically taken as being the sequence of transactions that including the full history of changes. Given a sequence of transactions it is always possible to rebuild the active state after a prefix of those transactions has been applied~\cite{Zahnentferner2018:Chimeric}.


\eject{}
% -----------------------------------------------------------------------------
% \subsection{Ledger Integrity}
% As mentioned in the previous section, the new facts created by a rule can be authorized by a set of parties that is at most the parties whose authority has been gained by matching on existing facts. This restriction allows Rainfall to operate as an open system, where arbitrary new parties can join, and create whatever new facts and rules they see fit. In doing so, it is not possible for a new party to cause a fact to be created that is carries the authority of another party that did not explicitly agree to its creation. For example, consider the following rule:
% \begin{small}
% \begin{code}
%   rule  mint
%   await Mint [minter = ?m] gain m
%    to   say Coin [issuer = 'Isabelle, holder = m]
%          by {'Isabelle, m} use {transfer}
% \end{code}
% \end{small}
% An arbitrary party can add a @Mint@ fact to the system to trigger this rule, and state that they should be the holder of the new coin. However, there is no way for the rule to gain the authority of @Isabelle@, the usual coin issuer. As we will see in \REF our operational semantics performs a runtime check to ensure that the authority of all new facts created by a rule are covered by the authority that has been gained by matching against existing ones.

