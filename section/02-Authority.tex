
\clearpage{}


\begin{figure}
\begin{small}
\begin{alltt}
fact  Coin   [issuer: Party, holder: Party]
fact  Offer  [id: Symbol, giver: Party, receiver: Party]
fact  Accept [id: Symbol, accepter: Party]

rule  transfer
await Accept [id = ?i, accepter = ?a] gain a
  and Offer  [id = i,  giver = ?g, receiver = ?r] gain r
  and Coin   [issuer = ?s, holder = g] gain s
to
  say Coin  [issuer =  s, holder = r]
   by \{s, r\} use \{transfer\}
\end{alltt}
\end{small}
\caption{Coin Transfer Workflow}
\label{f:CoinTransfer}
\end{figure}


% -------------------------------------------------------------------------------------------------
\section{Facts, Rules and Authority}
Rainfall consists of two main components, a ledger of facts and a set of rules. Parties using the system add facts to the ledger, embodying those facts with their own authority. Rules attempt to match on collections of facts, and when successful consume some of the facts, and create new facts. The new facts are embodied with a subset of the authority of the matched facts.

\subsection{Facts}
Figure~\ref{f:CoinTransfer} contains the fact and rule definitions for a simple coin transfer workflow. A @fact@ declaration gives the \emph{tag} and \emph{payload} types of a particular sort of fact. In this example, a @Coin@ fact describes a single coin that has been created by an @issuer@ party and is currently held by a @holder@. An @Offer@ fact represents an offer by a coin holder, the @giver@, which offers to give their coin to a second party, the @receiver@. The offer also carries a value of abstract @Symbol@, type that is used to uniquely identify the offer. An @Accept@ fact represents that fact that the receiver of the offer does indeed wish to accept a coin offer with the given identifier.

As an example use, suppose we have facts of the above types currently on the ledger:
\begin{small}
\begin{code}
 Coin   [issuer = %Ivan, holder = %Alice]
 Offer  [id = '1234, giver = %Alice, receiver = %Bob]
\end{code}
\end{small}

Names prefixed by @\%@ are identifiers of parties (principles) using the system, and their values have type @Party@. Names prefixed by @'@ are symbols (strings), and their values have type @Symbol@. The facts reveal that @Alice@ wishes to transfer the coin she currently holds to @Bob@. If @Bob@ wishes to accept the transfer he can then add the following fact to the ledger:
\begin{small}
\begin{code}
 Accept [id = '1234, accepter = %Bob]
\end{code}
\end{small}

Given the @Coin@, @Offer@, and @Accept@ facts, the @transfer@ rule from Figure~\ref{f:CoinTransfer} can fire, which \emph{consumes} the three above facts and produces a new one:
\begin{small}
\begin{code}
 Coin [issuer = %Ivan, holder = %Bob]
\end{code}
\end{small}

This new fact shows that the coin now belongs to Bob, or alternatively, the old coin has been destroyed and a new one created that is owned by Bob. In financial terms this workflow is known as a \emph{bilateral transfer} because the receiver must explicitly accept the offered coin, rather than being an \emph{unilateral transfer}, where the receiver has no say in whether the transfer takes place.


\subsection{Rules}
The @transfer@ rule of Figure~\ref{f:CoinTransfer} how the facts of the above types can be combined. The rule is written in a syntax similar to existing production rule systems based on OPS5.







includes the fact and rule definitions for the Coin Transfer example from before, as well as a \emph{scenario} which specifies a representitive test case.

Describe facts and their meta data.

Describe the intended execution model. The rules specify the valid transitions of the system, but the timliness is left to the ambient system. We could have a managed system run by a trusted hosting company, or have multiple nodes connected in a distrubted ledger. The semantics itself does not pescribe the implementation.


