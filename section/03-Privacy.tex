
% -----------------------------------------------------------------------------
\section{Privacy}
\label{s:Privacy}

\begin{figure}
\begin{center}
\includegraphics{figure/coin-transfer-visibility.pdf}
\end{center}
\vspace{-2ex}
\caption{Fact Visibility in Monitored Coin Transfer}
\label{f:CoinTransferVisibility}
\end{figure}

In practical multi-party workflows it is often not desirable, or not legal, for all data used in the workflow to be provided to all parties. In the coin transfer example from \S\ref{s:FactsWeights}, we could assume that Alice would not want to reveal the total number of coins she holds to Bob, nor the item she wishes to purchase (the Guitar) to Isabelle. Conversely, it is often the case that the details of workflows \emph{must} be revealed to third parties that do not themselves authorize any of the facts used in the workflow. Details of transactions may be required to be sent to financial regulators that monitor the operation of markets, or to credit agencies that offer loans based on the spending patterns of their clients. For the sake of example, we extend the coin transfer workflow described in the previous section with an extra party, Mona, who monitors all coin transactions. Figure~\ref{f:CoinTransferVisibility} shows who can see which facts in diagramatic form. The associated transfer rule is as per Figure~\ref{f:CoinTransfer}, extending by listing Mona listed as an observer of the produced coin fact.


% -----------------------------------------------------------------------------
% TODO: How does a confirming party know which other parties to ask for confirmations?
% It may see some in the facts revealed to it, but if a fact has been blinded it may not
% know it can ask the parties listed in that fact. We may want to add an extra field
% to the transaction listing the parties involved, which is separate from the facts
% themselves. This seems like a design variable where we might want the extra list,
% or not, and both answers are valid.

\subsection{Transaction and Validation}
\label{s:Transactions}
Assume that Alice, Bob, Mona and Isabelle have their own computers in their own offices, each containing a subset of facts as per Figure~\ref{f:CoinTransferVisibility}. Each party also has a copy of the extended transfer rule. Alice decides that it time to perform the transfer, and builds the following transaction structure:

\begin{small}
\begin{code}
Transaction
 seq    = ... sequence number ...
 rule   = ... hash of the transfer rule ...
 input  = [ Offer [id = '1234, terms = "To purchase a Guitar"
                  giver = !Alice, receiver = !Bob]
            by  {!Alice}            obs {!Mona, !Bob}
            use {'transfer}         num  1

          , Accept [id = '1234, accepter = !Bob]
            by  {!Bob}              obs {!Mona, !Alice}
            use {'transfer}         num 1

          , Coin   [issuer = !Isabelle, holder = !Alice]
            by  {!Isabelle, !Alice} obs {!Mona}
            use {'transfer}         num 1 ]

 output = [ Coin   [issuer = !Isabelle, holder = !Bob]
            by  {!Isabelle, !Bob}   obs {!Mona}
            use {'transfer}         num 1 ]
\end{code}
\end{small}

The transaction includes a fresh sequence number as an identifier, the hash of the code of the transfer rule, the list of facts being spent (input) by the transaction, and the list of new fact created (output). Alice would now like the other parties to agree that this is a valid execution of the transfer rule, and update their own local databases. However, as per Figure ~\ref{f:CoinTransferVisibility} not all parties are entitled to see all facts listed in the transaction.

Recall from \S\ref{s:Observation} that a party $P$ can see a fact $F$ when it is listed in either its \emph{by-authority} set or its \emph{obs-authority} set. We express this as a simple predicate, where the functions \trm{auth-by} and \trm{auth-obs} retrieve the respective annotations from a fact value.
$$
\trm{sees}~ P~ F = |(\trm{auth-by}~F \cup \trm{auth-obs}~F) \cap \{P\}| \ge 0
$$
Applying this predicate to the facts in the transaction, Alice computes that 1) the @Offer@ and @Accept@ should be visible to Alice, Bob and Mona; 2) the input @Coin@ fact should be visible to Isabelle, Alice and Mona, and 3) the output @Coin@ fact should be visible to Isabelle, Bob and Mona. Importantly, the details of the transaction do not reveal how many coins Alice might happen to have when she builds it. Isabelle and Mona will already know how many coins Alice, has as they have seen previous coin transactions, but there is no reason for this information to appear in the transaction structure itself.

Alice cannot sent the complete transaction to all parties as they are not all entitled to see all the facts. Instead, Alice computes a \emph{restricted view} for each of the other parties using the `sees' predicate above, and blinds the facts that a particular party is not entitled to see before from their view.


% -----------------------------------------------------------------------------
\subsection{Transaction Views}
% Alice cannot sent the complete transaction from the previous section to Isabelle, as Isabelle is not entitled to see the contents of the Offer fact. However, Alice does wish Isabelle to know that transfer has taken place, and that Bob has agreed to it, because Isabelle is an authorizer of the Coin facts being moved. To achieve this Alice computes a \emph{restricted view} of the transaction for Isabelle, which consists of a blinded hash of the entire transaction, along with along with a version of the transaction structure where the facts that Isabelle is not entitled to see are replaced by blinded hashes of those facts.

For the sake of presentation, we will abbreviate the four weighted facts in the transaction structure from \S\ref{s:Transactions} as $d_1, d_2, d_3, d_4$. We use the letter $d$ as a mnemonic short for \emph{factoid} --- meaning an unreliable fact, and ``unreliable'' because the weight may be zero. We express the complete transaction as the following tuple, using $h(X)$ to mean the hash of value $X$.
$$
 (seq,~ h(tx), [d_1, d_2, d_3], [d_4])
$$
Here we have the transaction sequence number, hash of the transaction rule code, a list input factoids, and list of output factoids. We will compute the views for each party by replacing some of the factoids by their \emph{blinded hashes}. A blinded hash is a cryptographic hash which has been combined with a random salt value so that the source data cannot feasibly be recovered by brute force guessing. We will use $s_1 .. s_4$ as the salts for each factoid.

Before computing the view for each particular party, we will compute a transaction identifier by replacing all factoids in the transaction with their blinded hashes, then hashing the result. We will use this value in a moment.
$$
\begin{array}{rl}
 \hspace{-2ex} h((seq,~ h(tx), [h(d_1, s_1), h(d_2, s_2), h(d_3, s_3)], [h(d_4, s_4)]))
\end{array}
$$
This is a unique(ish) identifier for the transaction, provided the hash values are long enough that we will not see a collision in practice.

Now, as Isabelle is entitled to see the @Coin@ facts but not the @Offer@ and @Accept@ facts she receives a view containing the fact data and salt values for the Coin facts, but only the blinded hash of the @Offer@ and @Accept@ facts:
$$
\trm{Isabelle:}~~(seq,~ h(tx), [h(d_1, s_1), h(d_2, s_2), (d_3, s_3)], [(d_4, s_4)])
$$
Similarly, Bob is entitled to see the Offer, Accept and produced Coin fact, but not the consumed Coin fact, so receives a corresponding view. Note that Bob can infer what the consumed coin fact will be anyway, but we leave the discussion of this to the next section.
$$
\trm{Bob:}~~(seq,~ h(tx), [(d_1, s_1), (d_2, s_2), h(d_3, s_3)], [(d_4, s_4)])
$$
Finally, Mona is entitled to see everything so she gets the same unblinded transaction that Alice has.
$$
\trm{Mona:}~~(seq,~ h(tx), [(d_1, s_1), (d_2, s_2), (d_3, s_3)], [(d_4, s_4)])
$$
All four parties, including Alice, are then able to use their transaction view to compute the same transaction identifier. Isabelle does not have the data for the Offer and Accept facts, but as she knows their hashes she can still form the hash of the overall transaction. Isabelle also cannot feasibly determine what the Offer and Accept facts originally were because the hashes of these facts have been salted by random numbers $s_1, s_2$ that she does not know. Isabelle \emph{can} determine that the $giver$ and $receiver$ fields of the Offer fact must have been @!Alice@ and @!Bob@ respectively as she knows the rule that the transaction was generated from, and the rule code reveals that these fields must match the corresponding fields in the Coin facts that she does see. Isabelle does not see that a Coin is being transferred @"To purchase on Guitar"@. That information is none of her business.


% Note that Alice herself is not listed in the meta-data of the produced coin fact, but will certainly know what this fact is because she is the one forming the transaction. In this case we say that Alice is an \emph{incidental observer} of this fact. Although Alice knows that this fact will be added to Isabelle, Bob, and Mona's view of the store, she should not add it to her own store. As Alice is not a \emph{formal observer} of the fact, she will be notified of transactions that spend this fact, so cannot be sure about its weight once her own transaction has been processed.

% Note that Bob is not listed in the metadata of the consumed coin fact, but will be able to infer its contents anyway because according to the transfer rule, the fields must match data in facts that he can see.



% -----------------------------------------------------------------------------
\subsection{Consensus}
Once Alice has sent the appropriate restricted transaction view to each party those parties can compare it against their own view of the current ledger state and confirm whether they believe it is valid. Isabelle is able to see the complete number of coins that are currently held by Alice, so Bob can ask Isabelle to confirm that her view of the transaction is valid, and hence enough coins were available for the transfer. In a practical workflow Isabelle would likely represent a commercial Bank, and Bob would trust Isabelle to answer truthfully when asked if enough coins are available for a currency transfer, even though he does not want the Bank to know that he is adding to his collection of guitars. Likewise, Isabelle can ask Bob to confirm that his view of the transaction is valid, and that he really did accept the transfer.

For a concrete implementation there are many ways to manage the transaction confirmation process. For a small number of parties, such as to manage commercial workflows between banks, it could be sufficient for each party to confirm the transaction directly with all others. This would require $O(n^2)$ confirmations in practice, but in the happy case the only information that needs to be exchanged is that the confirming party agrees with the transaction of the given hash code. For a greater number of parties, cryptographically signed confirmation messages could be propagated with a peer-to-peer protocol~\cite{El-Ansary2003:Broadcast}, or Byzantine Fault Tolerant (BFT) consensus protocol~\cite{Lamport1982:Byzantine, Ongaro2014:Consensus, Gilad2017:Algorand}



% Each transaction has a unique(ish) identifier consisting of the transaction hash, so each confirmation message is not a large amount of data.


% In hostile environment such as on the public internet the confirmations could be propagated via a , or one additionally resistant to Sybil attacks~\cite{}.

% Our programming model is not specific to any specific consensus mechanism, and different mechanisms are appropriate for different environments, so we do not seek to specify one here.


% -----------------------------------------------------------------------------
\subsection{Authorization Flow}
Note that in our system there is nothing preventing a party from adding a fact to the system which says ``I have a million dollars'', just with their own authority. As mentioned in \label{s:Authority} we allow parties to add arbitrary facts with their own authority, and delete fact that only authorized with their own authority. In the transaction structure of \S\ref{s:Transactions} this is achieved just by leaving the @rule@ field empty, as well as either the @spent@ or @new@ fields. The key property we need to manage is whether anyone else in the system should \emph{believe} those facts.

Recall that in the coin transfer example from \S\ref{s:Facts}, the coin facts always carry the authority of multiple parties, which is justified by the sequence of transactions that result in their production. The coin issuer (@Isabelle@ in the example) creates the initial coin facts, specifies the rules for using them, and signs the facts with their own authority. When the coins are transferred onwards the transactions recording the use of the transfer rule are also signed by the parties that propose them. Assuming most parties in the system are honest, invalid transactions will simply not be confirmed. Dishonest parties are free to corrupt their own databases by adding invalid transactions, but honest parties will not accept transactions that do not agree with their own view of the facts.

%  As with the consensus mechanism, our programming model does not specify a particular dispute mechanism, as different mechanisms are appropriate for different environments. In a commercial banking system it would be a rare occurrence for a party to actively propose an invalid transaction, so it may be appropriate to pause the system and investigate the issue manually. In a hostile internet environment it maybe instead be appropriate to blacklist the submitting party and not accept further transactions from them.

% -----------------------------------------------------------------------------
\subsection{Nested Transactions}
\label{s:NestedTransactions}
For the transaction described in \S\ref{s:Transactions}, the view to be given to Isabelle is constructed by blinding the @Offer@ and @Accept@ facts, as Isabelle is not an observer of these. Blinding these facts means that that Isabelle cannot use the information on the transaction to directly re-execute the rule and check the output. In an application where there is trusted monitor party such as Mona, this may not matter, as the monitor could be trusted to re-execute the transaction themselves and answer truthfully when asked if they believe it is valid. If we instead wish to allow Isabelle to validate the transaction output based on the input facts she can see, we can split the transfer rule into two parts: one part that checks that Alice and Bob agree on the offer, and another part concerning the actual coin transfer:

\begin{small}
\begin{code}
  rule  agreeOffer
  await Accept [id = ?i, accepter = ?a]            gain {a}
    and Offer  [id = i,  giver = g, receiver = ?a] gain {g}
  to
   say  Agreed [giver = g,   receiver = a]
    by  {g, a} obs {!Mona, !Isabelle}

  rule  doTransfer
  await Agreed [giver  = ?g, receiver = ?a] gain {g, a}
   and  Coin   [issuer = ?s, holder   = g]  gain {s, g}
  to
   say  Coin   [issuer = s,  holder   = a]
    by  {s, a} obs {!Mona, s, a}
\end{code}
\end{small}

With these two rule definitions Alice can build a nested transaction \CITE. For our purposes it is sufficient to represent a nested transaction as containing a list of sub-transactions as per the layout described in \S\ref{s:Transactions}, but with its own overall hash based identifier formed by combining the hashes of the sub-transactions. For the example above, the first sub-transaction will consume the @Accept@ and @Offer@ facts and produce and @Agreed@ fact with both Alice and Bob's authority. The second sub-transaction will immediately consume the @Agreed@ fact along with the @Coin@ fact, and produce a new @Coin@ fact. Importantly, both the created @Agreed@ fact in the first transaction, as well as the input @Coin@ fact are guaranteed to be visible to Isabelle, so she will be able to re-run the second sub-transaction and validate the output herself. Isabelle will still not be able to see the terms of the offer, but will be able to confirm with both Alice and Bob that they both agreed to it.

% The fact that some parties in a distributed system may not see all the components of a nested transaction is a common to most distributed database implementations.

% \TODO{Cite the XA distributed transaction model}.
% \TODO{Cite Corda Tearoffs}.
% \TODO{Cite Fabric private transactions} mentioned in DAML blog post.
% https://medium.com/daml-driven/keeping-smart-contracts-private-is-hard-unless-you-truly-understand-them-920b31d723e4

% TODO: contrast with DAML. In a DAML choice execution we always combine the authority
% of the contract instance with the controller of the choice. Both the signatories of the
% initial contract instance, and the controller can always see the full transaction, so
% we end up with partially blinded transactions like the first form of 'transfer'.


% -----------------------------------------------------------------------------
\subsection{Upgrade}
\label{s:Upgrade}
In practical information systems it is often necessary to upgrade data formats and business rules as requirements change over time. The fact that sets of rule names attached to each fact can be manipulated from the term language makes it easy to perform upgrades. For example, we can perform an upgrade of the business rules associated with @Coin@ fact using an upgrade rule such as:

\begin{small}
\begin{code}
  rule  upgrade
  await Coin [ issuer = ?s, holder = ?h ]  gain {s, h}
    and LetsUpgrade [ rules = ?rs ]     gain {!Operator}
    and YeahOk      [ party = s, rules = ?rs ] gain {s}
    and YeakOk      [ party = h, rules = ?rs ] gain {h}
   to
    say Coin [ issuer = s, holder = h ]
     by {s, h} use rs
\end{code}
\end{small}

Here, and @!Operator@ party adds an @UpgradePropose@ fact with a set of new rules that should be swapped in for the @use@ set of each coin. Once both the issuer and holder add facts that state they accept this upgrade the old coins can be consumed and new ones created that have the new @use@ set. The ability to upgrade the coins is specified by including the name of the upgrade rule in their original @use@ set (or not), but the new business rules can be specified after the initial coin facts have been generated.


% -----------------------------------------------------------------------------
\begin{figure}
\begin{center}
\includegraphics{figure/auction-visibility.pdf}
\end{center}
\vspace{-2ex}
\caption{Fact Visibility in Auction Example}
\label{f:AuctionVisibility}
\end{figure}


\subsection{Query}
\label{s:Query}
In our examples so far, each matching clause in a rule has always selected a single fact. In contrast, consider an auction workflow where we will need to rank offers by price, instead of just selecting any which matches. The fact visibility of such a workflow is depicted in Figure~\ref{f:AuctionVisibility}. Mark runs the auction market, Brendan is a broker, and Alice is a customer. The house rules are such that a customer (Alice) may not bid on items directly. Instead, the customer enlists a broker (Brendan) to which they provide an @Order@ describing the sort of @Item@ they wish to purchase, and their price limit. Naturally, the details of the @Order@ are private between the broker and customer, as the party running the auction house should not know the absolute maximum price a customer is willing to pay. During the auction, the market announces which items are for sale, including their lot number, description, and asking price. If anyone wishes to pay the asking price then the item is sold immediately. Bids may also be entered below the asking price, and the market will then communicate with the original owner of the item (not shown) about whether they are willing to sell at that lower price. The following rule shows how the broker can enter bids with the joint authority of themselves, as well as their customer:

\begin{small}
\begin{code}
fact Item  [lot: Nat, desc: Text, ask: Nat]
fact Order [buyer:  Party, desc: Text, limit: Nat]
fact Enter [broker: Party, lot: Nat, offer: Nat]
fact Bid  [broker: Party, buyer: Party, lot: Nat, offer: Nat]

  rule  bid
  await Item   [lot = ?n, desc = ?d, ask = ?a]
               select first a   consume none
    and Order  [buyer  = ?y, desc = d, limit = ?l] gain {y}
    and Enter  [broker = ?k, lot  = n, offer = ?o] gain {k}
         where o <= l && o <= a
  to
    say Bid    [buyer = y, broker = k, lot = n, offer = o]
     by {y, k} obs {!Mark}
\end{code}
\end{small}

In the first matching clause we have used @select first a@ to indicate that all matching @Item@ facts should be sorted by the asking price, and the first (cheapest) one selected. As the @Item@ fact is an announcement, rather than an asset to be ``spent'', we add @consume none@ to indicate the fact should not be consumed in the match. We have also added a @where@ clause to indicate that the offer entered by the broker must be no greater than the asking price for the item, or the limit of the customer. This allows the broker to use their own knowledge to try to get a better deal for the customer.

Finally, note that the transaction views generated from this rule that are given to Mark will have Alice's order fact blinded. In a practical implementation of an auction house workflow it may not be necessary for Mark to confirm the validity of each view in real time with Alice. Instead, after the auction is completed, if there is any dispute about about Brendan's involvement then he can provide the full transaction which includes Alice's signed order, as proof that he was acting in good faith.



